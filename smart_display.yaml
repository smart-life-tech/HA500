# known values 'MIDDLE_LEFT', valid options are 'TOP_LEFT', 'TOP_MID', 'TOP_RIGHT', 'LEFT_MID', 'CENTER', 'RIGHT_MID', 'BOTTOM_LEFT', 'BOTTOM_MID', 'BOTTOM_RIGHT'.
substitutions:
  name: "phijo-smart-device"
  friendly_name: "Phijo Smart"
  device_description: " Smart Controller"
  project_name: "Guition.ESP32_S3_4848S040"
  project_version: "1.0.2"
  wifi_ssid: ""
  wifi_password: ""
  lightbulb: "\U000F0335"
  ceiling_light: "\U000F0769"
  lamp: "\U000F06B5"
  floor_lamp: "\U000F08DD"
  string_lights: "\U000F12BA"
  settings_icon: "\U000F0493"
  home_icon: "\U000F02DC"
  sun_icon: "\U000F0599"
  moon_icon: "\U000F0F64"
  rain_icon: "\U000F0596"
  thermometer_icon: "\U000F050F"

esphome:
  name: "${name}"
  friendly_name: "${friendly_name}"
  project:
    name: "${project_name}"
    version: "${project_version}"
  platformio_options:
    board_build.flash_mode: dio
    build_unflags: "-f"
    build_flags:
      - "-shared"
      #- "-DCONFIG_ESP_MAIN_TASK_STACK_SIZE=8192"
  on_boot:
    priority: -100.0
    then:
      - delay: 6s # Wait for LVGL to be ready
      - lambda: |-
          id(lvgl_comp).show_page(8, LV_SCR_LOAD_ANIM_FADE_ON, 400);
          ESP_LOGD("BOOT", "Displaying splash logo");
      - delay: 500ms
      - lambda: |-
          auto now = id(time_comp).now();
          auto sunrise_opt = id(sun_comp).sunrise(0.0);
          auto sunset_opt = id(sun_comp).sunset(0.0);
          ESP_LOGI("light_time", "BOOT: time_valid=%d sunrise_available=%d sunset_available=%d lat=%.4f lon=%.4f",
                   now.is_valid() ? 1 : 0,
                   sunrise_opt.has_value() ? 1 : 0,
                   sunset_opt.has_value() ? 1 : 0,
                   37.2637f, -8.2292f);
          if (now.is_valid()) {
            if (sunrise_opt.has_value() && sunset_opt.has_value()) {
              ESP_LOGI("light_time", "BOOT: now=%02d:%02d sunrise=%02d:%02d sunset=%02d:%02d",
                       now.hour, now.minute,
                       sunrise_opt.value().hour, sunrise_opt.value().minute,
                       sunset_opt.value().hour, sunset_opt.value().minute);
            } else {
              ESP_LOGW("light_time", "BOOT: sun times unavailable - sun component may need restart after time sync");
            }
          } else {
            ESP_LOGW("light_time", "BOOT: time invalid - sun component needs valid time to calculate sunrise/sunset");
          }
      - delay: 5s
      - lambda: |-
          id(lvgl_comp).show_page(0, LV_SCR_LOAD_ANIM_FADE_ON, 400);
          ESP_LOGD("BOOT", "Hiding splash logo and showing main page");
      - delay: 2s
      # Push global into number on startup
      - lambda: |-
          //id(total_runtime).publish_state(id(total_runtime_multiple));
          ESP_LOGD("BOOT RUNTIME", ": %.2f minutes", id(global_cycles_count));
          // Jump to your first page (id 0 or whatever main is)
          id(lvgl_comp).show_page(0, LV_SCR_LOAD_ANIM_FADE_ON, 400);
          ESP_LOGD("BOOT", "Showing main page");
      - number.set:
          id: pool_length
          value: !lambda "return id(global_pool_length);"
      - number.set:
          id: pool_width
          value: !lambda "return id(global_pool_width);"
      - number.set:
          id: pool_depth
          value: !lambda "return id(global_pool_depth);"
      - number.set:
          id: cycle_number
          value: !lambda "return id(global_cycles_count);"
      # Show/hide free blocks based on restored pump_runtime_blocks value
      - if:
          condition:
            lambda: "return id(pump_runtime_blocks) >= 2;"
          then:
            - lvgl.widget.show: free_block2_settings
          else:
            - lvgl.widget.hide: free_block2_settings
      - if:
          condition:
            lambda: "return id(pump_runtime_blocks) >= 3;"
          then:
            - lvgl.widget.show: free_block3_settings
          else:
            - lvgl.widget.hide: free_block3_settings
      - if:
          condition:
            lambda: "return id(pump_runtime_blocks) >= 4;"
          then:
            - lvgl.widget.show: free_block4_settings
          else:
            - lvgl.widget.hide: free_block4_settings
      # Update pump settings page labels with restored values
      - lvgl.label.update:
          id: winter_min_display
          text: !lambda |-
            static char text[15];
            snprintf(text, sizeof(text), "%.2f hrs", id(winter_min_runtime));
            return text;
      - lvgl.label.update:
          id: ref_temp_display
          text: !lambda |-
            static char text[10];
            snprintf(text, sizeof(text), "%.1f°C", id(reference_temperature));
            return text;
      - lvgl.label.update:
          id: temp_rate_display
          text: !lambda |-
            static char text[15];
            snprintf(text, sizeof(text), "%.1f%%/°C", id(temp_rate_percent));
            return text;
      - lvgl.label.update:
          id: center_time_display
          text: !lambda |-
            static char text[10];
            snprintf(text, sizeof(text), "%02d:00", id(center_pump_time_hour));
            return text;
      - lvgl.label.update:
          id: runtime_blocks_display
          text: !lambda |-
            static char text[5];
            snprintf(text, sizeof(text), "%d", id(pump_runtime_blocks));
            return text;
      - lvgl.label.update:
          id: free_block2_display
          text: !lambda |-
            static char text[10];
            snprintf(text, sizeof(text), "%02d:%02d", id(free_block2_start_hour), id(free_block2_start_minute));
            return text;
      - lvgl.label.update:
          id: free_block3_display
          text: !lambda |-
            static char text[10];
            snprintf(text, sizeof(text), "%02d:%02d", id(free_block3_start_hour), id(free_block3_start_minute));
            return text;
      - lvgl.label.update:
          id: free_block4_display
          text: !lambda |-
            static char text[10];
            snprintf(text, sizeof(text), "%02d:%02d", id(free_block4_start_hour), id(free_block4_start_minute));
            return text;
      - lvgl.label.update:
          id: pool_length_number
          text: !lambda |-
            static char buf[20];
            snprintf(buf, sizeof(buf), "%.2f", id(global_pool_length));
            return buf;
      - lvgl.label.update:
          id: pool_width_number
          text: !lambda |-
            static char buf[20];
            snprintf(buf, sizeof(buf), "%.2f", id(global_pool_width));
            return buf;
      - lvgl.label.update:
          id: pool_depth_number
          text: !lambda |-
            static char buf[20];
            snprintf(buf, sizeof(buf), "%.2f", id(global_pool_depth));
            return buf;
      - lvgl.label.update:
          id: pump_flow_number
          text: !lambda |-
            static char buf[20];
            snprintf(buf, sizeof(buf), "%.1f", id(pump_flow_rate));
            return buf;

      - lvgl.label.update:
          id: cycles_number
          text: !lambda |-
            static char text[20];
            snprintf(text, sizeof(text), "%.2f", id(global_cycles_count));
            return text;
      - lvgl.label.update:
          id: blocks_number
          text: !lambda |-
            static char buf[20];
            sprintf(buf, "%d", id(pump_runtime_blocks));
            return buf;
      # Reset manual override timers to enable automation
      - lambda: |-
          id(sw1_manual_override_time) = 0;
          id(sw2_manual_override_time) = 0;
          id(sw3_manual_override_time) = 0;
          
          // Force correct runtime defaults if they got corrupted
          if (id(winter_min_runtime) < 0.5f || id(winter_min_runtime) > 8.0f) {
            id(winter_min_runtime) = 2.0f;
            ESP_LOGI("BOOT", "Reset winter_min_runtime to 2.0h");
          }
          if (id(summer_max_runtime) < 1.0f || id(summer_max_runtime) > 12.0f) {
            id(summer_max_runtime) = 5.0f;
            ESP_LOGI("BOOT", "Reset summer_max_runtime to 5.0h");
          }
          if (id(center_pump_time_hour) < 0 || id(center_pump_time_hour) > 23) {
            id(center_pump_time_hour) = 14;
            ESP_LOGI("BOOT", "Reset center_pump_time_hour to 14");
          }
          
          // Log ALL critical persisted values loaded from NVS
          ESP_LOGI("BOOT", "=== POOL DIMENSIONS LOADED ===");
          ESP_LOGI("BOOT", "Pool length=%.2f m width=%.2f m depth=%.2f m", 
                   id(global_pool_length), id(global_pool_width), id(global_pool_depth));
          ESP_LOGI("BOOT", "Pool volume=%.2f m³ cycles=%.2f pump_flow=%f L/h",
                   id(global_pool_length) * id(global_pool_width) * id(global_pool_depth),
                   id(global_cycles_count), id(pump_flow_rate));
          
          ESP_LOGI("BOOT", "=== PUMP SETTINGS LOADED ===");
          ESP_LOGI("BOOT", "winter_min=%.2fh summer_max=%.2fh center_hour=%d blocks=%d",
                   id(winter_min_runtime), id(summer_max_runtime), 
                   id(center_pump_time_hour), id(pump_runtime_blocks));
          ESP_LOGI("BOOT", "total_runtime_multiple=%.2fh calculated_daily_runtime=%d min",
                   id(total_runtime_multiple), id(calculated_daily_runtime));
          
          ESP_LOGI("BOOT", "=== LIGHT SETTINGS LOADED ===");
          ESP_LOGI("BOOT", "automation_mode=%d sunset_duration=%.1fh sunrise_duration=%.1fh manual_duration=%.1fh",
                   id(automation_mode), id(sunset_duration_hours), id(sunrise_duration_hours), id(manual_duration_hours));
      
      # Restore automation mode button states based on loaded automation_mode value
      - if:
          condition:
            lambda: "return id(automation_mode) == 0;"
          then:
            - lvgl.widget.update:
                id: mode_duration_btn
                state:
                  checked: true
            - lvgl.widget.update:
                id: mode_until_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_between_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_manual_btn
                state:
                  checked: false
      - if:
          condition:
            lambda: "return id(automation_mode) == 1;"
          then:
            - lvgl.widget.update:
                id: mode_duration_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_until_btn
                state:
                  checked: true
            - lvgl.widget.update:
                id: mode_between_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_manual_btn
                state:
                  checked: false
      - if:
          condition:
            lambda: "return id(automation_mode) == 2;"
          then:
            - lvgl.widget.update:
                id: mode_duration_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_until_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_between_btn
                state:
                  checked: true
            - lvgl.widget.update:
                id: mode_manual_btn
                state:
                  checked: false
      - if:
          condition:
            lambda: "return id(automation_mode) == 3;"
          then:
            - lvgl.widget.update:
                id: mode_duration_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_until_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_between_btn
                state:
                  checked: false
            - lvgl.widget.update:
                id: mode_manual_btn
                state:
                  checked: true
      - lambda: |-
          ESP_LOGI("BOOT", "Light automation mode buttons restored to mode=%d", id(automation_mode));
          
          ESP_LOGI("BOOT", "=== IRRIGATION SETTINGS LOADED ===");
          ESP_LOGI("BOOT", "seasonal_enabled=%d winter_mode=%d bucket_volume=%.1fL valve_lpm=%.2f",
                   id(seasonal_pump_enabled), id(sw3_winter_mode), 
                   id(bucket_volume_liters), id(valve_liters_per_minute));
          
          ESP_LOGI("BOOT", "Manual override timers reset - automation enabled");
      # Calculate irrigation needs to set up pump runtime
      - delay: 100ms
      - script.execute: calculate_irrigation_needs
      - delay: 50ms
      # Explicitly refresh UI labels with restored total_runtime_multiple value
      - lvgl.label.update:
          id: summer_max_display
          text: !lambda |-
            static char text[15];
            snprintf(text, sizeof(text), "%.2f hrs", id(total_runtime_multiple));
            return text;
      - lvgl.label.update:
          id: pump_runtime_label
          text: !lambda |-
            static char buf[16];
            snprintf(buf, sizeof(buf), "%.2f", id(total_runtime_multiple));
            return buf;
      - lambda: |-
          ESP_LOGI("BOOT", "Irrigation calculation executed - daily_runtime=%d minutes", id(calculated_daily_runtime));
          ESP_LOGI("BOOT", "UI labels refreshed with total_runtime_multiple=%.2f hours", id(total_runtime_multiple));
      # Wait for Home Assistant to finish syncing pool dimensions, then recalculate runtime
      - delay: 1500ms
      - lambda: |-
          // After HA syncs, recalculate runtime from pool dimensions
          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth);
          float flow = id(pump_flow_rate);
          float cycles = id(global_cycles_count);
          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;
          
          if (flow <= 0.1f) flow = 1.0f;
          float temp_factor = 1.0f;
          if (temp > 40.0f) temp_factor = 1.3f;
          else if (temp < 20.0f) temp_factor = 0.8f;
          
          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
          if (runtime > 24.0f) runtime = 24.0f;
          
          id(total_runtime_multiple) = runtime;
          id(total_runtime).publish_state(runtime);
          ESP_LOGI("BOOT", "Post-HA recalculation: volume=%.2fm³ flow=%.0fL/h cycles=%.1f → runtime=%.2f hours",
                   volume, flow, cycles, runtime);
      - script.execute: save_and_refresh_runtime
esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      COMPILER_OPTIMIZATION_SIZE: y
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: y
      CONFIG_SPIRAM_RODATA: y
      CONFIG_FATFS_LFN_STACK: "y"

psram:
  mode: octal
  speed: 80MHz

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

external_components:
  source: components

preferences:
  flash_write_interval: 30s # Save preferences every 60 seconds
# logger:
#   level: DEBUG
#   baud_rate: 115200
#   logs:
#     api: DEBUG
#     lvgl: DEBUG
#     lvgl_comp: DEBUG
#     irrigation: DEBUG
#     ota: DEBUG
#     time: DEBUG
web_server:
  port: 80
  version: 2
  include_internal: false
  local: true

# Enable Home Assistant API
api:
  reboot_timeout: 0s # Disable automatic reboot on API connection loss
  encryption:
    key: !secret encryption_key
  id: api_server
  on_client_connected:
    then:
      - logger.log: "API DEBUG: Home Assistant connected"
      - delay: 2s
      - script.execute: time_display_update
  on_client_disconnected:
    then:
      - logger.log: "API DEBUG: Home Assistant disconnected"
      - script.execute: time_display_update
ota:
  - platform: esphome
    id: my_ota
    password: !secret ota_password
    on_begin:
      then:
        - logger.log: "OTA start"
        - light.turn_on: backlight
        - lvgl.resume:
        #- lvgl.widget.show: popup_obj
        - lvgl.resume:
        - lvgl.widget.redraw:
    # on_progress:
    #   then:
    #     - lvgl.bar.update:
    #         id: popup_pb_percentage
    #         value: !lambda "return (int)x;"
    #     - lvgl.label.update:
    #         id: popup_lbl_percentage
    #         text:
    #           format: "OTA progress %0.1f%%"
    #           args: ["x"]
    #     - lambda: "id(lvgl_comp).loop();"
sensor:
  - platform: template
    name: "Pool Volume"
    id: pool_volume
    unit_of_measurement: "m³"
    accuracy_decimals: 2
    lambda: |-
      return id(global_pool_length) * id(global_pool_width) * id(global_pool_depth);
    update_interval: 30s

  - platform: template
    name: "Total Runtime"
    id: total_runtime
    unit_of_measurement: "h"
    accuracy_decimals: 2
    update_interval: 30s
    lambda: |-
      float V = id(pool_length).state * id(pool_width).state * id(pool_depth).state;
      return V / id(pump_flow_rate);

  - platform: template
    name: "Runtime per Block"
    id: runtime_per_block
    unit_of_measurement: "h"
    accuracy_decimals: 2
    lambda: |-
      float V = id(pool_length).state * id(pool_width).state * id(pool_depth).state;
      float T = V / id(pump_flow_rate);
      return T /  id(pump_runtime_blocks);

  - platform: template
    name: "Adjusted Runtime"
    id: adjusted_runtime
    unit_of_measurement: "h"
    accuracy_decimals: 2
    lambda: |-
      float V = id(pool_length).state * id(pool_width).state * id(pool_depth).state;
      float T = V / id(pump_flow_rate);
      float temp = id(pool_temp);
      return T * (1.0 + id(temp_rate_percent) * (temp - id(reference_temperature)));

  - platform: template
    name: "Total Runtime (Multiple Cycles)"
    unit_of_measurement: "h"
    accuracy_decimals: 2
    lambda: |-
      float V = id(pool_length).state * id(pool_width).state * id(pool_depth).state;
      float T = V / id(pump_flow_rate);
      return id(cycles) * T;

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_rssi
    update_interval: 60s

  - platform: template
    name: "Daily Evaporation"
    id: daily_evaporation_sensor
    unit_of_measurement: "L"
    accuracy_decimals: 1
    lambda: "return id(calculated_evaporation_liters);"
    update_interval: 300s

  - platform: template
    name: "Watering Needed"
    id: irrigation_needed_sensor
    unit_of_measurement: "L"
    accuracy_decimals: 1
    lambda: "return id(irrigation_needed_liters);"
    update_interval: 300s

  - platform: template
    name: "Daily Rainfall"
    id: daily_rainfall_sensor
    unit_of_measurement: "mm"
    accuracy_decimals: 1
    lambda: "return id(daily_rainfall_mm);"
    update_interval: 300s

  - platform: template
    name: "Field Area"
    id: field_area_sensor
    unit_of_measurement: "m2"
    accuracy_decimals: 0
    lambda: "return id(field_area_m2);"
    update_interval: never

  - platform: template
    name: "Valve Flow Rate"
    id: valve_flow_rate_sensor
    unit_of_measurement: "L/min"
    accuracy_decimals: 1
    lambda: "return id(valve_liters_per_minute);"
    update_interval: never

  - platform: template
    name: "OWM Temperature"
    id: owm_temperature
    unit_of_measurement: "°C"
    accuracy_decimals: 1

  - platform: template
    name: "OWM Humidity"
    id: owm_humidity
    unit_of_measurement: "%"
    accuracy_decimals: 0

  - platform: template
    name: "OWM Pressure"
    id: owm_pressure
    unit_of_measurement: "hPa"
    accuracy_decimals: 0

  - platform: template
    name: "OWM Wind Speed"
    id: owm_wind_speed
    unit_of_measurement: "m/s"
    accuracy_decimals: 1

  - platform: template
    name: "OWM Feels Like"
    id: owm_feels_like
    unit_of_measurement: "°C"
    accuracy_decimals: 1

  # ADDing NEW SENSORS
  - platform: template
    name: "OWM Visibility"
    id: owm_visibility
    unit_of_measurement: "km"
    accuracy_decimals: 1

  - platform: template
    name: "OWM Cloud Coverage"
    id: owm_clouds
    unit_of_measurement: "%"
    accuracy_decimals: 0

  - platform: template
    name: "OWM Wind Gust"
    id: owm_wind_gust
    unit_of_measurement: "m/s"
    accuracy_decimals: 1

  - platform: template
    name: "OWM Wind Direction"
    id: owm_wind_direction
    unit_of_measurement: "°"
    accuracy_decimals: 0

http_request:
  id: http_requests
  useragent: "ESPHome/1.0"
  timeout: 30s # Increase timeout
  verify_ssl: false
  follow_redirects: true
  buffer_size_rx: 1024 # Add buffer size

wifi:
  # networks:
  #   - ssid: !secret wifi_ssid3
  #     password: !secret wifi_password3
  #     priority: 100
  #   - ssid: !secret wifi_ssid2
  #     password: !secret wifi_password2
  #     priority: 90
  #   - ssid: !secret wifi_ssid
  #     password: !secret wifi_password
  #     priority: 80

  # Added parameters for better connection reliability
  # power_save_mode: LIGHT
  # fast_connect: false # Disable for better reliability with multiple networks
  # reboot_timeout: 0s  # Reboots if no Wi-Fi connection is made
  # output_power: 20.0
  # enable_rrm: true
  # enable_btm: true

  # Existing fallback AP configuration
  ap:
    ssid: "PhiJo Smart Products"
    password: !secret wifi_fallback_password

  # Existing event handlers
  on_connect:
    then:
      - delay: 10s
      - logger.log: "WiFi connected, starting web server"
      #- script.execute: update_qr_display  # Update QR code
      - delay: 1s
      - script.execute: notify_web_portal

  on_disconnect:
    then:
      - logger.log: "WiFi disconnected, attempting to reconnect"
      - script.execute: notify_web_portal
      #- script.execute: update_qr_display  # Update QR code

captive_portal:

time:
  - platform: homeassistant
    id: time_comp
    timezone: "Europe/Lisbon"
    on_time_sync:
      then:
        - logger.log: "TIME DEBUG: Time synchronized with Home Assistant"
        - script.execute: time_display_update # Changed from time_update
    on_time:
      # Check every minute if we should start irrigation
      - seconds: 0
        then:
          - lambda: |-
              if (!id(auto_irrigation_enabled)) return;

              auto now = id(time_comp).now();
              int current_minutes = now.hour * 60 + now.minute;
              bool should_start = false;

              // Recalculate daily runtime first
              id(calculate_irrigation_needs).execute();

              // Check center block timing
              int center_half_time = id(center_block_runtime) / 2;
              int center_start = (id(center_pump_time_hour) * 60) - center_half_time;
              int center_end = (id(center_pump_time_hour) * 60) + center_half_time;

              if (current_minutes == center_start) {
                ESP_LOGI("irrigation", "Starting center block irrigation");
                should_start = true;
              }

              // Check free blocks
              if (id(pump_runtime_blocks) >= 2 && current_minutes == (id(free_block2_start_hour) * 60 + id(free_block2_start_minute))) {
                ESP_LOGI("irrigation", "Starting free block 2 irrigation");
                should_start = true;
              }

              if (id(pump_runtime_blocks) >= 3 && current_minutes == (id(free_block3_start_hour) * 60 + id(free_block3_start_minute))) {
                ESP_LOGI("irrigation", "Starting free block 3 irrigation");
                should_start = true;
              }

              if (id(pump_runtime_blocks) >= 4 && current_minutes == (id(free_block4_start_hour) * 60 + id(free_block4_start_minute))) {
                ESP_LOGI("irrigation", "Starting free block 4 irrigation");
                should_start = true;
              }

              if (should_start && !id(sw2).state) {
                id(run_scheduled_irrigation).execute();
              }

  # Add SNTP as fallback when Home Assistant is unavailable
  - platform: sntp
    id: sntp_time
    timezone: "Europe/Lisbon"
    servers:
      - "pool.ntp.org"
      - "time.nist.gov"
      - "time.google.com"
    on_time_sync:
      then:
        - logger.log: "TIME DEBUG: Time synchronized with SNTP server"
        - if:
            condition:
              not:
                api.connected:
            then:
              - script.execute: time_display_update

# For the sun component, we need to use fixed values initially
sun:
  latitude: 37.2637  # Pico Alto, Portugal (from geocoding)
  longitude: -8.2292 # Pico Alto, Portugal (from geocoding)
  id: sun_comp

# Add this to update the sun component when location changes
number:
  - platform: template
    name: "cycle number"
    id: cycle_number
    min_value: 0
    max_value: 3
    step: 0.5
    initial_value: 0.5
    optimistic: true
    on_value:
      then:
        - globals.set:
            id: cycles_count
            value: !lambda "return (int)x;"
        - lvgl.widget.redraw: # Refresh all widgets on the current page

  - platform: template
    name: "block number"
    id: block_number
    min_value: 1
    max_value: 4
    step: 1
    lambda: |-
      return id(pump_runtime_blocks);
    set_action:
      then:
        - globals.set:
            id: pump_runtime_blocks
            value: !lambda "return (int)x;"
        - component.update: block_number
        - lvgl.widget.redraw: # Refresh all widgets on the current page

  - platform: template
    name: "Pool Length"
    id: pool_length
    min_value: 0.1
    max_value: 10
    step: 0.1
    initial_value: 1.0
    optimistic: true
    #restore_value: true
    on_value:
      then:
        - globals.set:
            id: global_pool_length
            value: !lambda "return x;"
        - globals.set:
            id: total_runtime_multiple
            value: !lambda "return id(total_runtime).state;"

        - sensor.template.publish:
            id: pool_volume
            state: !lambda "return id(global_pool_length) * id(global_pool_width) * id(global_pool_depth);"
        - lvgl.label.update:
            id: pool_volume_number
            text: !lambda |-
              char buf[32];
              snprintf(buf, sizeof(buf), "%.2f", 
                       id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
              return buf;
        - lvgl.widget.redraw: # Refresh all widgets on the current page
  - platform: template
    name: "Pool Width"
    id: pool_width
    min_value: 0.1
    max_value: 10
    step: 0.1
    initial_value: 1.0
    optimistic: true
    restore_value: true
    on_value:
      then:
        - globals.set:
            id: global_pool_width
            value: !lambda "return x;"
        - globals.set:
            id: total_runtime_multiple
            value: !lambda "return id(total_runtime).state;"
        - sensor.template.publish:
            id: pool_volume
            state: !lambda "return id(global_pool_length) * id(global_pool_width) * id(global_pool_depth);"
        - lvgl.label.update:
            id: pool_volume_number
            text: !lambda |-
              char buf[32];
              snprintf(buf, sizeof(buf), "%.2f", 
                       id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
              return buf;
        - lvgl.widget.redraw:
  - platform: template
    name: "Pool Depth"
    id: pool_depth
    min_value: 0.1
    max_value: 50
    step: 0.1
    initial_value: 1.0
    optimistic: true
    #restore_value: true
    on_value:
      then:
        - globals.set:
            id: global_pool_depth
            value: !lambda "return x;"
        - sensor.template.publish:
            id: pool_volume
            state: !lambda "return id(global_pool_length) * id(global_pool_width) * id(global_pool_depth);"
        - lvgl.label.update:
            id: pool_volume_number
            text: !lambda |-
              char buf[32];
              snprintf(buf, sizeof(buf), "%.2f", 
                       id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
              return buf;
        - lvgl.widget.redraw:
  #   name: "Pool Length"
  #   id: pool_length
  #   min_value: 0.1
  #   max_value: 10
  #   step: 0.1
  #   initial_value: 1.0
  #   optimistic: true
  #   restore_value: true
  # - platform: template
  #   name: "Pool Width"
  #   id: pool_width
  #   min_value: 0.1
  #   max_value: 10
  #   step: 0.1
  #   initial_value: 1.0
  #   optimistic: true
  #   restore_value: true
  # - platform: template
  #   name: "Pool Depth"
  #   id: pool_depth
  #   min_value: 0.1
  #   max_value: 50
  #   step: 0.1
  #   initial_value: 1.0
  #   optimistic: true
  #   restore_value: true
  - platform: template
    name: "Temperature Adjustment Factor (per °C)"
    id: temp_coeff
    optimistic: true
    min_value: 0.00
    max_value: 0.10
    step: 0.001
    initial_value: 0.02
    #restore_value: true
  - platform: template
    name: "Reference Temperature (°C)"
    id: temp_ref
    optimistic: true
    min_value: 0
    max_value: 40
    step: 0.5
    initial_value: 25.0

  # Seasonal settings
  - platform: template
    id: winter_min_input
    min_value: 0
    max_value: 90
    step: 0.1
    lambda: |-
      return id(winter_min_runtime);
    set_action:
      then:
        - globals.set:
            id: winter_min_runtime
            value: !lambda "return x;"
        - component.update: winter_min_input

  - platform: template
    id: summer_max_input
    min_value: 0
    max_value: 600
    step: 0.1
    optimistic: true
    initial_value: 3
    on_value:
      then:
        - lambda: "id(summer_max_runtime) = x;"

  - platform: template
    id: center_time_hour_input
    min_value: 10
    max_value: 18
    step: 1
    optimistic: true
    initial_value: 14
    on_value:
      then:
        - lambda: "id(center_pump_time_hour) = (int)x;"

  - platform: template
    id: reference_temp_input
    min_value: 15
    max_value: 30
    step: 0.5
    lambda: |-
      return id(reference_temperature);
    set_action:
      then:
        - globals.set:
            id: reference_temperature
            value: !lambda "return x;"
        - component.update: reference_temp_input

  - platform: template
    id: temp_rate_input
    min_value: 0.5
    max_value: 3.0
    step: 0.1
    optimistic: true
    initial_value: 1.0
    on_value:
      then:
        - lambda: "id(temp_rate_percent) = x;"

  - platform: template
    id: runtime_blocks_input
    min_value: 1
    max_value: 4
    step: 1
    optimistic: true
    initial_value: 1
    on_value:
      then:
        - lambda: "id(pump_runtime_blocks) = (int)x;"
        - lambda: |-
            if (x >=2) {
             lv_obj_clear_flag(id(free_block2_settings), LV_OBJ_FLAG_HIDDEN);
            }else{
             lv_obj_add_flag(id(free_block2_settings), LV_OBJ_FLAG_HIDDEN);
            }
            if (x >=3) {
             lv_obj_clear_flag(id(free_block3_settings), LV_OBJ_FLAG_HIDDEN);
             }else{
             lv_obj_add_flag(id(free_block3_settings), LV_OBJ_FLAG_HIDDEN);
             }
             if (x >=4) {
             lv_obj_clear_flag(id(free_block4_settings), LV_OBJ_FLAG_HIDDEN);
             }else{
             lv_obj_add_flag(id(free_block4_settings), LV_OBJ_FLAG_HIDDEN);
             }

  # Free block start times
  - platform: template
    id: free_block2_hour_input
    min_value: 0
    max_value: 23
    step: 1
    optimistic: true
    initial_value: 8
    on_value:
      then:
        - lambda: "id(free_block2_start_hour) = (int)x;"

  - platform: template
    id: free_block2_minute_input
    min_value: 0
    max_value: 59
    step: 1
    optimistic: true
    initial_value: 0
    on_value:
      then:
        - lambda: "id(free_block2_start_minute) = (int)x;"

  - platform: template
    id: free_block3_hour_input
    min_value: 0
    max_value: 23
    step: 1
    optimistic: true
    initial_value: 18
    on_value:
      then:
        - lambda: "id(free_block3_start_hour) = (int)x;"

  - platform: template
    id: free_block3_minute_input
    min_value: 0
    max_value: 59
    step: 1
    optimistic: true
    initial_value: 0
    on_value:
      then:
        - lambda: "id(free_block3_start_minute) = (int)x;"

  - platform: template
    id: free_block4_hour_input
    min_value: 0
    max_value: 23
    step: 1
    optimistic: true
    initial_value: 21
    on_value:
      then:
        - lambda: "id(free_block4_start_hour) = (int)x;"

  - platform: template
    id: free_block4_minute_input
    min_value: 0
    max_value: 59
    step: 1
    optimistic: true
    initial_value: 0
    on_value:
      then:
        - lambda: "id(free_block4_start_minute) = (int)x;"

  - platform: template
    id: daily_rainfall_input
    name: "Daily Rainfall (mm)"
    min_value: 0
    max_value: 100
    step: 0.5
    ##restore_value: yes
    initial_value: 0
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(daily_rainfall_mm) = x;
            ESP_LOGI("irrigation", "Daily rainfall updated to %.1f mm", x);
        - script.execute: calculate_irrigation_needs
        # - lvgl.label.update:
        #     id: rainfall_manual_display
        #     text: !lambda |-
        #       static char text[20];
        #       snprintf(text, sizeof(text), "%.1f mm", id(daily_rainfall_mm));
        #       return text;

  - platform: template
    id: irrigation_schedule_hour_input
    name: "Watering Schedule Hour"
    min_value: 0
    max_value: 23
    step: 1
    ##restore_value: yes
    initial_value: 6
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(irrigation_schedule_hour) = (int)x;
        # - lvgl.label.update:
        #     id: schedule_time_display
        #     text: !lambda |-
        #       static char text[20];
        #       snprintf(text, sizeof(text), "%02d:%02d", id(irrigation_schedule_hour), id(irrigation_schedule_minute));
        #       return text;

  - platform: template
    id: irrigation_schedule_minute_input
    name: "Watering Schedule Minute"
    min_value: 0
    max_value: 59
    step: 15
    ##restore_value: yes
    initial_value: 0
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(irrigation_schedule_minute) = (int)x;
        # - lvgl.label.update:
        #     id: schedule_time_display
        #     text: !lambda |-
        #       static char text[20];
        #       snprintf(text, sizeof(text), "%02d:%02d", id(irrigation_schedule_hour), id(irrigation_schedule_minute));
        #       return text;
  - platform: template
    id: field_area_input
    name: "Field Area (m2)"
    min_value: 1
    max_value: 1000
    step: 1
    ##restore_value: yes
    initial_value: 48
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(field_area_m2) = x;
            ESP_LOGI("irrigation", "Field area updated to %.0f m²", x);
        - script.execute: calculate_irrigation_needs
        # - lvgl.label.update:
        #     id: field_area_display
        #     text: !lambda |-
        #       static char text[20];
        #       snprintf(text, sizeof(text), "%.0f m2", id(field_area_m2));
        #       return text;

  - platform: template
    id: valve_flow_rate_input
    name: "Valve Flow Rate (L/H)"
    min_value: 1
    max_value: 100
    step: 0.5
    #restore_value: yes
    initial_value: 20
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(valve_liters_per_minute) = x;
            ESP_LOGI("irrigation", "Valve flow rate updated to %.1f L/min", x);
        # - lvgl.label.update:
        #     id: flow_rate_display
        #     text: !lambda |-
        #       static char text[20];
        #       snprintf(text, sizeof(text), "%.1f L/min", id(valve_liters_per_minute));
        #       return text;

  - platform: template
    id: location_latitude
    name: "Location Latitude"
    min_value: -90
    max_value: 90
    step: 0.01
    restore_value: true
    initial_value: 37.1 # Default to a central location
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(sun_comp).set_latitude(id(location_latitude).state);

  - platform: template
    id: location_longitude
    name: "Location Longitude"
    min_value: -180
    max_value: 180
    step: 0.01
    restore_value: true
    initial_value: -8.0 # Default to a central location
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(sun_comp).set_longitude(id(location_longitude).state);
  # NEW: Light automation number inputs
  - platform: template
    id: sunset_hours_input
    name: "Sunset Duration Hours"
    min_value: 1
    max_value: 12
    step: 1
    restore_value: true
    initial_value: 2
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(sunset_duration_hours) = (int)x;
            
            // If light is currently ON in Duration mode, recalculate off_time with new duration
            if (id(sw1).state && id(automation_mode) == 0 && id(sw1_manual_override_time) == 0) {
              auto now = id(time_comp).now();
              auto sunset_opt = id(sun_comp).sunset(0.0);
              
              uint32_t seconds_since_midnight = (now.hour * 3600u) + (now.minute * 60u) + now.second;
              uint32_t day_start_ts = now.timestamp - seconds_since_midnight;
              uint32_t sunset_ts;
              
              if (sunset_opt.has_value()) {
                sunset_ts = sunset_opt.value().timestamp;
              } else {
                // Compute approximate sunset for Portugal
                int day_of_year = now.day_of_year;
                float season_factor = sin((day_of_year - 80) * M_PI / 182.5f);
                int sunset_h = 18 + (int)(season_factor * 2.5f);
                int sunset_m = 30 + (int)(season_factor * 15.0f);
                sunset_ts = day_start_ts + (uint32_t)(sunset_h * 3600 + sunset_m * 60);
              }
              
              // Recalculate off_time with new duration
              uint32_t new_off_time = sunset_ts + (id(sunset_duration_hours) * 3600);
              id(sw1_off_time) = new_off_time;
              
              int mins_left = (new_off_time - now.timestamp) / 60;
              ESP_LOGI("automation", "Duration changed: Light off_time updated to %d mins from now", mins_left);
            }
        - lvgl.label.update:
            id: sunset_hours_display
            text: !lambda |-
              static char text[20];
              snprintf(text, sizeof(text), "%d hours", id(sunset_duration_hours));
              return text;

  - platform: template
    id: sunrise_hours_input
    name: "Sunrise Duration Hours"
    min_value: 0
    max_value: 6
    step: 1
    restore_value: true
    initial_value: 1
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(sunrise_duration_hours) = (int)x;
        - lvgl.label.update:
            id: sunrise_hours_display
            text: !lambda |-
              static char text[20];
              snprintf(text, sizeof(text), "%d hours", id(sunrise_duration_hours));
              return text;

  - platform: template
    id: manual_hours_input
    name: "Manual Duration Hours"
    min_value: 1
    max_value: 24
    step: 1
    restore_value: true
    initial_value: 4
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(manual_duration_hours) = (int)x;
            
            // If light ON in Manual mode, recalculate off_time with new manual duration
            if (id(sw1).state && id(automation_mode) == 3 && id(sw1_manual_override_time) == 0) {
              auto now = id(sntp_time).now();
              if (!now.is_valid()) return;
              
              // Recalculate off_time from now
              uint32_t new_off_time = now.timestamp + (id(manual_duration_hours) * 3600);
              id(sw1_off_time) = new_off_time;
              
              int mins_left = (new_off_time - now.timestamp) / 60;
              ESP_LOGI("automation", "Manual Duration changed: Light off_time updated to %d mins from now", mins_left);
            }
        - lvgl.label.update:
            id: manual_hours_display
            text: !lambda |-
              static char text[20];
              snprintf(text, sizeof(text), "%d hours", id(manual_duration_hours));
              return text;

  - platform: template
    id: until_time_hour_input
    name: "Until Time Hour"
    min_value: 0
    max_value: 23
    step: 1
    restore_value: true
    initial_value: 23
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(sunset_until_time_hour) = (int)x;
            
            // If light ON in Until Time mode, recalculate off_time with new until_time
            if (id(sw1).state && id(automation_mode) == 1 && id(sw1_manual_override_time) == 0) {
              auto now = id(sntp_time).now();
              if (!now.is_valid()) return;
              
              // Calculate target off time (sunset until specified HH:MM)
              uint32_t day_start_ts = now.timestamp - (now.hour * 3600) - (now.minute * 60) - now.second;
              uint32_t until_ts = day_start_ts + (id(sunset_until_time_hour) * 3600) + (id(sunset_until_time_minute) * 60);
              
              // If until_time is earlier than now, it means next day
              if (until_ts < now.timestamp) {
                until_ts += 86400; // Add 24 hours
              }
              
              // Update off_time
              id(sw1_off_time) = until_ts;
              
              int mins_left = (until_ts - now.timestamp) / 60;
              ESP_LOGI("automation", "Until Time changed: Light off_time updated to %d mins from now", mins_left);
            }
        - lvgl.label.update:
            id: until_time_display
            text: !lambda |-
              static char text[20];
              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
              return text;

  - platform: template
    id: until_time_minute_input
    name: "Until Time Minute"
    min_value: 0
    max_value: 59
    step: 15
    restore_value: true
    initial_value: 0
    optimistic: true
    on_value:
      then:
        - lambda: |-
            id(sunset_until_time_minute) = (int)x;
            
            // If light ON in Until Time mode, recalculate off_time with new until_time
            if (id(sw1).state && id(automation_mode) == 1 && id(sw1_manual_override_time) == 0) {
              auto now = id(sntp_time).now();
              if (!now.is_valid()) return;
              
              // Calculate target off time (sunset until specified HH:MM)
              uint32_t day_start_ts = now.timestamp - (now.hour * 3600) - (now.minute * 60) - now.second;
              uint32_t until_ts = day_start_ts + (id(sunset_until_time_hour) * 3600) + (id(sunset_until_time_minute) * 60);
              
              // If until_time is earlier than now, it means next day
              if (until_ts < now.timestamp) {
                until_ts += 86400; // Add 24 hours
              }
              
              // Update off_time
              id(sw1_off_time) = until_ts;
              
              int mins_left = (until_ts - now.timestamp) / 60;
              ESP_LOGI("automation", "Until Time changed: Light off_time updated to %d mins from now", mins_left);
            }
        - lvgl.label.update:
            id: until_time_display
            text: !lambda |-
              static char text[20];
              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
              return text;
# binary sensors for irrigation status
binary_sensor:
  - platform: template
    name: "Watering Required"
    id: irrigation_required
    lambda: "return id(irrigation_needed_liters) > 5.0;"

  - platform: template
    name: "Training Mode Active"
    id: training_mode_active
    lambda: "return id(valve_training_mode);"

text_sensor:
  - platform: lvgl
    widget: zip_text
    id: zip_text_sensor
    name: "ZIP Code"

  - platform: lvgl
    widget: country_text
    id: country_text_sensor
    name: "Country"

  - platform: wifi_info
    ssid:
      name: "Connected SSID"
      id: wifi_ssid
      entity_category: diagnostic
    bssid:
      name: "Connected BSSID"
      id: wifi_bssid
      entity_category: diagnostic
    mac_address:
      name: "Mac Address"
      id: wifi_mac
      entity_category: diagnostic
    scan_results:
      name: "WiFi Scan Results"
      id: wifi_scan
      entity_category: diagnostic

  - platform: template
    name: "WiFi Gateway"
    id: wifi_gateway
    lambda: |-
      //auto gateway = wifi::global_wifi_component->wifi_sta_ip_config().gateway;
      return {"192.168.0.1"}; // Replace with actual gateway retrieval logic
    update_interval: 60s

  - platform: template
    name: "WiFi Subnet"
    id: wifi_subnet
    lambda: |-
      //auto subnet = wifi::global_wifi_component->wifi_sta_ip_config().subnet;
      return {"255.255.255.0"}; // Replace with actual subnet retrieval logic
    update_interval: 60s

  - platform: template
    name: "WiFi DNS"
    id: wifi_dns
    lambda: |-
      //auto dns1 = wifi::global_wifi_component->wifi_sta_ip_config().dns1;
      return {"192.168.0.1"}; // Replace with actual DNS retrieval logic";
    update_interval: 60s

  - platform: template
    id: weather_condition
    name: "Weather Condition"

  - platform: template
    id: weather_description
    name: "Weather Description"

  - platform: wifi_info
    ip_address:
      name: "IP Address"
      id: ip_address
      entity_category: diagnostic
      on_value:
        then:
          - logger.log:
              format: "Raw IP string: '%s' (length: %d)"
              args: ["x.c_str()", "x.length()"]
          - lambda: |-
              ESP_LOGI("ip_debug", "Hex dump of IP string:");
              for (size_t i = 0; i < x.length() && i < 50; i++) {
                ESP_LOGI("ip_debug", "  [%02d]: 0x%02X '%c'", i, (unsigned char)x[i], 
                         std::isprint(x[i]) ? x[i] : '?');
              }
          - delay: 1s
          #- script.execute: update_qr_display

  - platform: template
    id: location_name
    name: "Weather Location"
    lambda: |-
      return {id(location_name_str)};
  - platform: template
    name: "Watering Status"
    id: irrigation_status
    lambda: |-
      if (id(valve_training_mode)) {
        return {"Training Mode Active"};
      } else if (id(sw3).state) {
        return {"Irrigating"};
      } else if (id(irrigation_needed_liters) > 10) {
        return {"Watering Needed"};
      } else if (id(daily_rainfall_mm) > 5) {
        return {"Recently Watered by Rain"};
      } else {
        return {"Optimal"};
      }
    update_interval: 60s

  - platform: template
    name: "Next Watering Time"
    id: next_irrigation_time
    lambda: |-
      auto now = id(time_comp).now();
      if (!now.is_valid()) return {"Time not available"};

      // Calculate next appropriate irrigation time
      int current_hour = now.hour;
      std::string next_time = "";

      if (id(irrigation_needed_liters) > 10) {
        if (current_hour < 5) {
          next_time = "05:00 (Morning)";
        } else if (current_hour < 18) {
          next_time = "18:00 (Evening)";
        } else if (current_hour < 20) {
          next_time = "Now (Evening window)";
        } else {
          next_time = "Tomorrow 05:00";
        }
      } else {
        next_time = "Not needed";
      }

      return {next_time};
    update_interval: 300s
color:
  # Create a Home Assistant blue color
  - id: ha_blue
    hex: 51c0f2
  - id: green_color
    red: 0%
    green: 60%
    blue: 0%
  - id: red_color
    red: 80%
    green: 0%
    blue: 0%
  - id: orange_color
    red: 100%
    green: 60%
    blue: 0%
  - id: blue_color
    red: 0%
    green: 40%
    blue: 100%
  - id: black_color
    red: 0%
    green: 0%
    blue: 0%
  - id: white_color
    red: 100%
    green: 100%
    blue: 100%
  - id: yellow_color
    red: 100%
    green: 100%
    blue: 0%

# Global variables for timer tracking and settings
globals:
  - id: user_zip_code
    type: std::string
    restore_value: true
    max_restore_data_length: 10
    #initial_value: '"94040"'  # default ZIP

  - id: user_country
    type: std::string
    restore_value: true
    max_restore_data_length: 10
    #initial_value: '"US"'     # default country

  - id: current_lat
    type: float
    restore_value: true
    initial_value: "37.1"
  - id: current_lon
    type: float
    restore_value: true
    initial_value: "-8.0"

  - id: global_pool_length
    type: float
    restore_value: true
    initial_value: "1.0"

  - id: global_pool_width
    type: float
    restore_value: true
    initial_value: "1.0"

  - id: global_pool_depth
    type: float
    restore_value: true
    initial_value: "1.0"

  - id: global_temp_coeff
    type: float
    restore_value: true
    initial_value: "0.02"

  - id: global_temp_ref
    type: float
    restore_value: true
    initial_value: "25.0"

  - id: pump_flow_rate
    type: float
    initial_value: "20000.0"
    restore_value: true

  - id: pool_temperature
    type: float
    initial_value: "25.0"

  - id: cycles
    type: int
    initial_value: "0"
    restore_value: true

  - id: cycles_count
    type: float
    restore_value: true
    initial_value: "1.00"

  - id: global_cycles_count
    type: float
    restore_value: true
    initial_value: "1.50"

  - id: total_runtime_multiple
    type: float
    restore_value: true
    initial_value: "5.00"

  - id: pool_temp
    type: float
    initial_value: "25.0" # Default pool temperature
  - id: num_blocks
    type: int
    initial_value: "1"
  - id: seasonal_pump_enabled
    type: bool
    initial_value: "true"
    restore_value: true
  - id: winter_min_runtime
    type: float
    initial_value: "2.00"
    restore_value: true
  - id: summer_max_runtime
    type: float
    initial_value: "5.0"
    restore_value: true
  - id: center_pump_time_hour
    type: int
    initial_value: "14"
    restore_value: true
  - id: reference_temperature
    type: float
    initial_value: "22.0"
    restore_value: true
  - id: temp_rate_percent
    type: float
    initial_value: "1.0"
    restore_value: true

  # Runtime scheduling
  - id: pump_runtime_blocks
    type: int
    initial_value: "1" # 1, 2, 3, or 4 blocks
    restore_value: true

  - id: calculated_daily_runtime
    type: int
    initial_value: "0"
  - id: center_block_runtime
    type: int
    initial_value: "0"
  - id: free_block_runtime
    type: int
    initial_value: "0"

  # Free schedulable block times (blocks 2, 3, 4)
  - id: free_block2_start_hour
    type: int
    initial_value: "8"
    restore_value: true
  - id: free_block2_start_minute
    type: int
    initial_value: "0"
    restore_value: true
  - id: free_block3_start_hour
    type: int
    initial_value: "18"
    restore_value: true
  - id: free_block3_start_minute
    type: int
    initial_value: "0"
    restore_value: true
  - id: free_block4_start_hour
    type: int
    initial_value: "21"
    restore_value: true
  - id: free_block4_start_minute
    type: int
    initial_value: "0"
    restore_value: true

  - id: irrigation_duration_remaining
    type: int
    restore_value: no
    initial_value: "0"

  - id: last_touch_time
    type: unsigned long
    initial_value: "0"

  - id: irrigation_schedule_hour
    type: int
    restore_value: true
    initial_value: "6" # Default 6 AM

  - id: irrigation_schedule_minute
    type: int
    restore_value: true
    initial_value: "0" # Default 6:00 AM

  - id: auto_irrigation_enabled
    type: bool
    restore_value: true
    initial_value: "true"
  # Watering system globals
  - id: field_area_m2
    type: float
    #restore_value: yes
    initial_value: "48.0" # Default 48 m² field area

  - id: wifi_popup_visible
    type: bool
    #restore_value: yes
    initial_value: "false"

  - id: valve_training_mode
    type: bool
    #restore_value: yes
    initial_value: "false"

  - id: valve_training_start_time
    type: int
    restore_value: no
    initial_value: "0"

  - id: bucket_volume_liters
    type: float
    restore_value: true
    initial_value: "10.0" # Default 10L calibration bucket

  - id: valve_liters_per_minute
    type: float
    restore_value: true
    initial_value: "20.0" # Default 20 L/min flow rate

  - id: daily_rainfall_mm
    type: float
    restore_value: no
    initial_value: "0.0"

  - id: calculated_evaporation_liters
    type: float
    restore_value: no
    initial_value: "0.0"

  - id: irrigation_needed_liters
    type: float
    restore_value: no
    initial_value: "0.0"

  - id: sw3_on_time
    type: int
    restore_value: no
    initial_value: "0"

  - id: qr_text_value
    type: std::string
    restore_value: no
    initial_value: '"http://192.168.4.1/"'

  - id: location_name_str
    type: std::string
    restore_value: true
    initial_value: '"Sao Bartolomeu de Messines, Portugal"'
  # Timer tracking
  - id: sw1_off_time
    type: int
    #restore_value: yes
    initial_value: "0"
  - id: sw2_off_time
    type: int
    #restore_value: yes
    initial_value: "0"
  - id: sw3_off_time
    type: int
    #restore_value: yes
    initial_value: "0"
  - id: sw1_before_sunrise
    type: bool
    #restore_value: yes
    initial_value: "false"

  # Manual override tracking
  - id: sw1_manual_override_time
    type: int
    #restore_value: yes
    initial_value: "0"
  - id: sw2_manual_override_time
    type: int
    #restore_value: yes
    initial_value: "0"
  - id: sw3_manual_override_time
    type: int
    #restore_value: yes
    initial_value: "0"

  # SW3 mode (winter/summer)
  - id: sw3_winter_mode
    type: bool
    #restore_value: yes
    initial_value: "false" # Default to summer mode

  # Current page tracking
  - id: current_page
    type: int
    restore_value: no
    initial_value: "0" # 0 = main page, 1 = settings page

  # Add this missing global variable for touch tracking
  - id: touch_start_y
    type: int
    restore_value: no
    initial_value: "0"
  - id: touch_end_y
    type: int
    restore_value: no
    initial_value: "0"
  - id: touch_active
    type: bool
    restore_value: no
    initial_value: "false"
  # NEW: Light automation settings
  - id: sunset_duration_hours
    type: int
    restore_value: true
    initial_value: "2" # Default 2 hours after sunset

  - id: sunrise_duration_hours
    type: int
    restore_value: true
    initial_value: "1" # Default 1 hour before sunrise

  - id: manual_duration_hours
    type: int
    restore_value: true
    initial_value: "4" # Default 4 hours for manual on

  - id: sunset_until_time_hour
    type: int
    restore_value: true
    initial_value: "23" # Default until 23:00

  - id: sunset_until_time_minute
    type: int
    restore_value: true
    initial_value: "0" # Default until 23:00

  - id: sunrise_from_time_hour
    type: int
    restore_value: true
    initial_value: "6" # Default from 06:00

  - id: sunrise_from_time_minute
    type: int
    restore_value: true
    initial_value: "0" # Default from 06:00

  - id: automation_mode
    type: int
    restore_value: true
    initial_value: "0" # 0=duration, 1=until_time, 2=between_times, 3=manual

button:
  - platform: template
    name: "Start Valve Training"
    id: start_training_button
    on_press:
      then:
        - script.execute: start_valve_training

  - platform: template
    name: "Calculate Watering Needs"
    id: calc_irrigation_button
    on_press:
      then:
        - script.execute: calculate_irrigation_needs

  - platform: template
    name: "Reset Daily Rainfall"
    id: reset_rainfall_button
    on_press:
      then:
        - lambda: |-
            id(daily_rainfall_mm) = 0.0f;
            ESP_LOGI("irrigation", "Daily rainfall reset to 0mm");

# Add select for irrigation mode
select:
  - platform: template
    name: "Watering Mode"
    id: irrigation_mode_select
    optimistic: true # Add this line
    options:
      - "Summer (High Evaporation)"
      - "Winter (Low Evaporation)"
    initial_option: "Summer (High Evaporation)"
    restore_value: true
    on_value:
      then:
        - lambda: |-
            if (x == "Winter (Low Evaporation)") {
              id(sw3_winter_mode) = true;
            } else {
              id(sw3_winter_mode) = false;
            }
            ESP_LOGI("irrigation", "Mode changed to: %s", x.c_str());
        - script.execute: calculate_irrigation_needs

#-------------------------------------------
# LVGL Interface
#-------------------------------------------
lvgl:
  id: lvgl_comp
  displays:
    - my_display
  touchscreens:
    - touchscreen_id: my_touchscreen

  bg_color: 0x000000
  on_ready:
    - logger.log: "LVGL ready → showing splash"
    - lvgl.widget.show: splash_logo
    - delay: 3s
    - lvgl.widget.hide: splash_logo
    - lvgl.page.show:
        id: main_page
        animation: fade_in
        time: 400ms

  on_idle:
    - timeout: 30s
      then:
        - logger.log: idle 30s timeout
        - light.turn_off:
            id: backlight
            transition_length: 5s
        - lvgl.pause:
            show_snow: true

  style_definitions:
    - id: style_line
      line_color: 0x0000FF
      line_width: 8
      line_rounded: true
    - id: date_style
      text_font: roboto24
      align: center
      text_color: 0x333333
      bg_opa: cover
      radius: 4
      #pad_all: 2
    - id: switch_style_on
      bg_color: 0x00AA00
      text_color: 0xFFFFFF
    - id: switch_style_off
      bg_color: 0x555555
      text_color: 0xCCCCCC
    - id: nav_button_style
      bg_color: 0x444444
      text_color: 0xFFFFFF
      radius: 15
      pad_all: 5
    - id: title_style
      bg_color: 0x1E3A8A
      text_color: 0xFFFFFF
      text_font: roboto24
      radius: 10
      pad_all: 8

  theme:
    button:
      text_font: roboto24
      scroll_on_focus: false
      radius: 25
      width: 150
      height: 60
      pad_left: 10px
      pad_top: 10px
      pad_bottom: 10px
      pad_right: 10px
      shadow_width: 0
      border_width: 0
      bg_color: 0x313131
      text_color: 0xB6B6B6
      checked:
        bg_color: 0xCC5E14
        text_color: 0xB6B6B6

  page_wrap: true
  pages:
    # Main Page - Dashboard with Clock, Date, Weather
    - id: main_page
      skip: false
      bg_color: 0x000000
      bg_opa: cover
      #pad_all: 0
      border_width: 0
      scrollable: false
      widgets:
        # Background image - fixed position
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT

        - obj:
            width: 50
            scrollable: false
            height: 50
            bg_opa: 0%
            x: 10
            y: 10
            border_width: 0
            widgets:
              - image:
                  id: wifi_space
                  src: wifi_icon_offline
                  x: -8
                  y: -4
                  width: 50
                  height: 50
                  bg_opa: 0% # Transparent background
                  border_width: 0

        # Title Bar
        - obj:
            width: 460
            scrollable: false # Add this
            height: 60
            bg_color: 0x1E3A8A
            bg_opa: 0%
            radius: 10
            x: 10
            y: 10
            border_width: 0
            widgets:
              - label:
                  text: "PHIJO SMART POOL"
                  text_font: roboto24
                  align: center
                  text_color: 0xFFFFFF
                  x: 0
                  y: 2
                  border_width: 0
        - obj:
            width: 460
            height: 140
            bg_color: 0x1E3A8A
            bg_opa: 0%
            radius: 10
            x: 10
            y: 30
            border_width: 0
            scrollable: false
            widgets:
              # Clock - positioned below title (fixed positioning)
              - label:
                  id: digital_clock
                  text: !lambda |-
                    auto now = id(time_comp).now();
                    if (!now.is_valid()) {
                      now = id(sntp_time).now();
                    }
                    static char time_buf[6];
                    sprintf(time_buf, "%02d:%02d", now.hour, now.minute);
                    return time_buf;
                  text_font: roboto_large
                  align: center
                  text_color: 0xFFFFFF
                  x: 145
                  y: 0
                  border_width: 0
                  width: 480

              # Date - positioned below clock (fixed positioning)

              - label:
                  id: full_date_label
                  text: "Date will appear here"
                  text_font: roboto24
                  align: center
                  text_color: 0xFFFFFF
                  x: 120
                  y: 45
                  border_width: 0
                  width: 480
                  scrollable: false # Add this

        # Weather section - semi-transparent overlay
        - obj:
            width: 460
            height: 250 # Increased height to fit more info
            bg_color: 0x000000
            bg_opa: 0%
            radius: 10
            #pad_all: 10
            x: 10
            y: 150 # Adjusted position
            border_width: 0
            scrollable: false
            widgets:
              # Main weather condition
              # Row 1: Main weather condition
              - image:
                  src: cloud_icon
                  x: 0
                  y: 70
              - label:
                  id: weather_label
                  text: !lambda |-
                    if (id(weather_condition).has_state()) {
                      return id(weather_condition).state.c_str();
                    }
                    return "Loading...";
                  text_font: roboto24
                  text_color: yellow_color
                  #align: TOP_LEFT
                  x: 40
                  y: 70
                  border_width: 0

              # Row 2: Temperature with icon
              - image:
                  src: thermometer_icon
                  x: 200
                  y: 70
              - label:
                  id: temperature_label
                  text: !lambda |-
                    if (id(owm_temperature).has_state()) {
                      static char temp_text[60];
                      if (id(owm_feels_like).has_state()) {
                        snprintf(temp_text, sizeof(temp_text), "%.1f°C feels %.1f°C", 
                                id(owm_temperature).state, id(owm_feels_like).state);
                      } else {
                        snprintf(temp_text, sizeof(temp_text), "%.1f°C", id(owm_temperature).state);
                      }
                      return temp_text;
                    }
                    return "--°C";
                  text_font: roboto24
                  text_color: yellow_color
                  #align: TOP_RIGHT
                  x: 235
                  y: 70
                  border_width: 0

              # Row 3: Humidity and Pressure with icons
              - image:
                  src: humidity_icon
                  x: 0
                  y: 120
              - label:
                  id: humidity_label
                  text: !lambda |-
                    if (id(owm_humidity).has_state()) {
                      static char hum_text[20];
                      snprintf(hum_text, sizeof(hum_text), "%.0f%%", id(owm_humidity).state);
                      return hum_text;
                    }
                    return "--%";
                  text_font: roboto24
                  #align: LEFT_MID
                  text_color: yellow_color
                  x: 30
                  y: 120

              - image:
                  src: pressure
                  x: 200
                  y: 120
              - label:
                  id: pressure_label
                  text: !lambda |-
                    if (id(owm_pressure).has_state()) {
                      static char press_text[20];
                      snprintf(press_text, sizeof(press_text), "%.0fhPa", id(owm_pressure).state);
                      return press_text;
                    }
                    return "--hPa";
                  text_font: roboto24
                  #align: RIGHT_MID
                  text_color: yellow_color
                  x: 230
                  y: 120

              # Row 4: Wind and Visibility with icons
              - image:
                  src: wind_icon
                  x: 0
                  y: 165
              - label:
                  id: wind_info_label
                  text: !lambda |-
                    if (id(owm_wind_speed).has_state()) {
                      static char wind_text[30];
                      if (id(owm_wind_gust).has_state() && id(owm_wind_gust).state > id(owm_wind_speed).state) {
                        snprintf(wind_text, sizeof(wind_text), "%.1fm/s (%.1f)", 
                                id(owm_wind_speed).state, id(owm_wind_gust).state);
                      } else {
                        snprintf(wind_text, sizeof(wind_text), "%.1fm/s", id(owm_wind_speed).state);
                      }
                      return wind_text;
                    }
                    return "--m/s";
                  text_font: roboto24
                  #align: BOTTOM_LEFT
                  text_color: yellow_color
                  x: 30
                  y: 165

              - image:
                  src: visibility_icon
                  x: 200
                  y: 165
              - label:
                  id: visibility_label
                  text: !lambda |-
                    if (id(owm_visibility).has_state()) {
                      static char vis_text[20];
                      snprintf(vis_text, sizeof(vis_text), "%.1fkm", id(owm_visibility).state);
                      return vis_text;
                    }
                    return "--km";
                  text_font: roboto24
                  #align: BOTTOM_LEFT
                  text_color: yellow_color
                  x: 230
                  y: 165

              # Row 5: Sunrise and Sunset times
              - label:
                  text: "☀️ Sunrise:"
                  text_font: roboto24
                  text_color: orange_color
                  x: 0
                  y: 210
              - label:
                  id: sunrise_time_label
                  text: "--:--"
                  text_font: roboto24
                  text_color: yellow_color
                  x: 140
                  y: 210

              - label:
                  text: "🌅 Sunset:"
                  text_font: roboto24
                  text_color: orange_color
                  x: 230
                  y: 210
              - label:
                  id: sunset_time_label
                  text: "--:--"
                  text_font: roboto24
                  text_color: yellow_color
                  x: 360
                  y: 210

              # Location name
              - label:
                  id: location_display_label
                  text: !lambda "return id(location_name_str);"
                  text_font: roboto24
                  align: center
                  text_color: black_color
                  x: 0
                  y: 110
                  border_width: 0
                  width: 440
                  clickable: true
                  on_press:
                    - lambda: |-
                        // Go to location settings page
                        id(lvgl_comp).show_page(7, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);
                        ESP_LOGI("ui", "Location label clicked — navigating to Set Location page");

        # Status and IP section
        - obj:
            width: 460
            scrollable: false # Add this
            height: 85
            bg_color: 0x000000
            bg_opa: 0%
            radius: 10
            x: 10
            y: 420
            border_width: 0
            widgets:
              - label:
                  id: status_label
                  hidden: true
                  text: "Ready"
                  text_color: 0xFFFFFF
                  text_font: roboto
                  align: center
                  x: 0
                  y: 5
                  border_width: 0
              - label:
                  id: ip_address_label
                  align: center
                  text: "WiFi: Not connected"
                  text_color: ha_blue
                  text_font: roboto
                  x: 0
                  y: 30

        # Navigation buttons
        - button:
            id: controls_nav_button
            x: 10
            y: 430
            width: 100
            height: 45
            styles: nav_button_style
            widgets:
              - label:
                  text: "Controls"
                  text_font: roboto
                  align: center
            on_click:
              then:
                - lambda: |-
                    id(current_page) = 1;
                - lvgl.page.next:

        - obj:
            id: wifi_popup_obj
            hidden: true
            x: 50
            y: 80
            width: 380
            height: 340
            bg_color: 0x000000
            bg_opa: 100%
            radius: 15
            border_width: 2
            border_color: 0x1E3A8A
            clickable: true
            scrollable: false
            widgets:
              # Popup title
              - label:
                  text: "WiFi Status Information"
                  text_font: roboto24
                  text_color: 0xFFFFFF

                  x: 0
                  y: 10
                  width: 380

              # WiFi Status
              - label:
                  text: "Status:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 50
              - label:
                  id: wifi_status_text
                  text: "Checking..."
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 50

              # SSID
              - label:
                  text: "SSID:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 75
              - label:
                  id: wifi_ssid_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 75

              # BSSID
              - label:
                  text: "BSSID:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 100
              - label:
                  id: wifi_bssid_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 100
                  width: 280

              # RSSI
              - label:
                  text: "Signal:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 125
              - label:
                  id: wifi_rssi_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 125

              # IP Address
              - label:
                  text: "IP:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 150
              - label:
                  id: wifi_ip_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 150

              # Gateway
              - label:
                  text: "Gateway:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 175
              - label:
                  id: wifi_gateway_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 175

              # Subnet
              - label:
                  text: "Subnet:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 200
              - label:
                  id: wifi_subnet_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 200

              # DNS
              - label:
                  text: "DNS:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 225
              - label:
                  id: wifi_dns_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 225

              # MAC Address
              - label:
                  text: "MAC:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 250
              - label:
                  id: wifi_mac_text
                  text: "N/A"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 80
                  y: 250
                  width: 280

              # Refresh button
              - button:
                  x: 10
                  y: 280
                  width: 100
                  height: 30
                  widgets:
                    - label:
                        text: "Refresh"
                        text_font: roboto
                        align: center

    # Controls Page - Light Control Buttons
    - id: controls_page
      skip: false
      bg_color: 0x000000
      bg_opa: cover
      pad_all: 0
      border_width: 0
      scrollable: false
      widgets:
        # Background image for controls page
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT

        # Update Switch 1 - Light Control
        - button:
            id: sw1_button
            radius: 40
            width: 340
            height: 70
            x: 40
            y: 50
            checkable: true
            widgets:
              - label:
                  text: "Light"
                  text_font: roboto24
                  align: center
            on_click:
              then:
                - switch.toggle: sw1
                - lambda: |-
                    id(sw1_manual_override_time) = id(time_comp).now().timestamp;
                    // If turning ON manually, set off time based on manual duration
                    if (id(sw1).state) {
                      auto now = id(time_comp).now();
                      id(sw1_off_time) = now.timestamp + (id(manual_duration_hours) * 3600);
                      ESP_LOGI("automation", "SW1 manual ON - will turn off in %d hours (at %u)", 
                               id(manual_duration_hours), id(sw1_off_time));
                    } else {
                      id(sw1_off_time) = 0;
                      ESP_LOGI("automation", "SW1 manual OFF - timer cleared");
                    }

        - image:
            src: settings_icon
            x: 390
            y: 50
            width: 60
            height: 60
        # Update Switch 2 - Water Pump
        - button:
            id: sw2_button
            radius: 40
            width: 340
            height: 70
            x: 40
            y: 140
            checkable: true
            widgets:
              - label:
                  text: "Pump"
                  text_font: roboto24
                  align: center
            on_click:
              then:
                - switch.toggle: sw2
                - lambda: |-
                    id(sw2_manual_override_time) = id(time_comp).now().timestamp;
        - image:
            src: settings_icon
            x: 390
            y: 140
            width: 60
            height: 60
        # Update Switch 3 - Watering Valve
        - button:
            id: sw3_button
            radius: 40
            width: 340
            height: 70
            x: 40
            y: 230
            checkable: true
            widgets:
              - label:
                  id: sw3_button_label
                  text: !lambda |-
                    if (id(valve_training_mode)) {
                      return "Valve (TRAINING MODE)";
                    } else if (id(sw3_winter_mode)) {
                      return " Valve (Winter)";
                    } else {
                      return " Valve (Summer)";
                    }
                  text_font: roboto24
                  align: center
            on_click:
              then:
                - switch.toggle: sw3
                - lambda: |-
                    id(sw3_manual_override_time) = id(time_comp).now().timestamp;
        - image:
            src: settings_icon
            x: 390
            y: 230
            width: 60
            height: 60
        # Add irrigation status display
        - obj:
            width: 340
            height: 80
            bg_color: 0x000000
            bg_opa: 5%
            radius: 40
            x: 40
            y: 315
            widgets:
              - label:
                  id: irrigation_summary_line1
                  text: !lambda |-
                    static char line1_text[60];
                    snprintf(line1_text, sizeof(line1_text), 
                            "Field: %.1f m^3 | Flow: %.1f L/min", 
                            id(pool_volume), id(pump_flow_rate));
                    return line1_text;
                  text_font: roboto
                  text_color: black_color
                  align: center
                  x: 0
                  y: -15
                  border_width: 0

              - label:
                  id: irrigation_summary_line2
                  hidden: true
                  text: !lambda |-
                    static char line2_text[60];
                    snprintf(line2_text, sizeof(line2_text), 
                            "Evap: %.1fL/day | Need: %.1fL", 
                            id(calculated_evaporation_liters), id(irrigation_needed_liters));
                    return line2_text;
                  text_font: roboto
                  text_color: black_color
                  align: center
                  x: 0
                  y: 10
                  border_width: 0

        # Navigation buttons
        - button:
            id: home_nav_button
            x: 10
            y: 430
            width: 100
            height: 45
            styles: nav_button_style
            widgets:
              - label:
                  text: "Back"
                  text_font: roboto
                  align: center
            on_click:
              then:
                #- lvgl.page.previous:
                - lambda: |-
                    // go to main page from control page
                    id(current_page) = 0;
                    id(lvgl_comp).show_page(0, LV_SCR_LOAD_ANIM_OVER_LEFT, 300);

        - button:
            id: settings_nav_button2
            x: 350
            y: 430
            width: 120
            height: 45
            styles: nav_button_style
            widgets:
              - label:
                  text: "Next"
                  text_font: roboto
                  align: center
            on_click:
              then:
                #- lvgl.page.next:
                - lambda: |-
                    // go to sttong page from control page
                    id(lvgl_comp).show_page(3, LV_SCR_LOAD_ANIM_OVER_LEFT, 300);

    # New Pump/Watering Settings Page
    - id: pump_settings_page
      scrollable: false

      widgets:
        # Background image for controls page
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT
        # - on_boot:
        #     then:
        #       - logger.log: "Pump Settings Page loaded"
        #       - lvgl.widget.redraw: # Refresh all widgets on the current page
        #         id: pump_settings_page
        # Seasonal Pump Settings Toggle
        - obj:
            scrollable: false
            width: 480
            height: 60
            bg_color: 0x000000
            bg_opa: 0%
            radius: 5
            x: 0
            y: 10
            border_width: 2
            widgets:
              - label:
                  text: "SEASONAL PUMP SET"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: -20
                  y: 0
                  align: center
              - button:
                  id: seasonal_toggle
                  x: 335
                  y: -6
                  width: 100
                  height: 40
                  checkable: true
                  radius: 10
                  widgets:
                    - label:
                        id: seasonal_label
                        text: !lambda |-
                          if (id(seasonal_pump_enabled)) {
                            return "ON";
                          } else {
                            return "OFF";
                          }
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          id(seasonal_pump_enabled) = !id(seasonal_pump_enabled);
                      - if:
                          condition:
                            lambda: "return id(seasonal_pump_enabled);"
                          then:
                            - lvgl.label.update:
                                id: seasonal_label
                                text: "ON"
                            - lambda: |-

                          else:
                            - lvgl.label.update:
                                id: seasonal_label
                                text: "OFF"
                  state:
                    checked: !lambda "return id(seasonal_pump_enabled);"
        # Runtime Settings
        - obj:
            scrollable: false
            width: 480
            height: 110
            bg_color: 0x000000
            bg_opa: 50%
            radius: 0
            x: 0
            y: 80
            border_width: 0
            widgets:
              - label:
                  text: "Runtime Settings"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 0
                  y: 0
              # pool button
              - button:
                  id: pump_nav_button
                  x: 200
                  y: -7
                  width: 100
                  radius: 10
                  height: 35
                  styles: nav_button_style
                  bg_color: 0x00FF00
                  widgets:
                    - label:
                        text: "Pool M^3."
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          // go to main page from settings page
                          id(lvgl_comp).show_page(6, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);
              # Done button
              - button:
                  id: pump_back_button
                  x: 335
                  y: -7
                  width: 100
                  height: 40
                  radius: 10
                  styles: nav_button_style
                  bg_color: 0x00FF00
                  widgets:
                    - label:
                        text: "Done"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          // go to main page from settings page
                          id(lvgl_comp).show_page(1, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);

              # Winter Min Runtime
              - label:
                  text: "Winter min:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 0
                  y: 35
              - button:
                  x: 90
                  y: 30
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: winter_min_input
                      - lvgl.label.update:
                          id: winter_min_display
                          text: !lambda |-
                            static char text[15];
                            if (id(winter_min_runtime) < 0) {
                              id(winter_min_runtime) = 0;
                            }
                            snprintf(text, sizeof(text), "%.2f hrs", id(winter_min_runtime));
                            return text;
              - label:
                  id: winter_min_display
                  text: !lambda |-
                    static char text[15];
                    snprintf(text, sizeof(text), "%.2f hrs", id(winter_min_runtime));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 125
                  y: 35
              - button:
                  x: 180
                  y: 30
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: winter_min_input
                      - lvgl.label.update:
                          id: winter_min_display
                          text: !lambda |-
                            static char text[15];
                            if (id(winter_min_runtime) > id(summer_max_runtime)) {
                              id(winter_min_runtime) = id(summer_max_runtime);
                            }
                            snprintf(text, sizeof(text), "%.2f hrs", id(winter_min_runtime));
                            return text;

              # Summer Max Runtime
              - label:
                  text: "Sum max:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 225
                  y: 35
              - button:
                  x: 310
                  y: 30
                  width: 30
                  hidden: true
                  height: 25
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: summer_max_input
                      - lvgl.label.update:
                          id: summer_max_display
                          text: !lambda |-
                            static char text[15];
                            snprintf(text, sizeof(text), "%.2f hrs", id(total_runtime_multiple));
                            return text;
              - label:
                  id: summer_max_display
                  text: !lambda |-
                    static char text[15];
                    snprintf(text, sizeof(text), "%.2f hrs", id(total_runtime_multiple));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 345
                  y: 35
              - button:
                  x: 410
                  y: 30
                  width: 30
                  hidden: true
                  height: 25
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: summer_max_input
                      - lvgl.label.update:
                          id: summer_max_display
                          text: !lambda |-
                            static char text[15];
                            snprintf(text, sizeof(text), "%.2f hrs", id(total_runtime_multiple));
                            return text;

              # Reference Temperature
              - label:
                  text: "Ref temp:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 0
                  y: 70
              - button:
                  x: 90
                  y: 66
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: reference_temp_input
                      - lvgl.label.update:
                          id: ref_temp_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%.1f°C", id(reference_temperature));
                            return text;
              - label:
                  id: ref_temp_display
                  text: !lambda |-
                    static char text[10];
                    snprintf(text, sizeof(text), "%.1f°C", id(reference_temperature));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 120
                  y: 70
              - button:
                  x: 180
                  y: 65
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: reference_temp_input
                      - lvgl.label.update:
                          id: ref_temp_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%.1f°C", id(reference_temperature));
                            return text;

              # Temperature Rate
              - label:
                  text: "Temp rate:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 215
                  y: 70
              - button:
                  x: 310
                  y: 70
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: temp_rate_input
                      - lvgl.label.update:
                          id: temp_rate_display
                          text: !lambda |-
                            static char text[15];
                            snprintf(text, sizeof(text), "%.1f%%/°C", id(temp_rate_percent));
                            return text;
              - label:
                  id: temp_rate_display
                  text: !lambda |-
                    static char text[15];
                    snprintf(text, sizeof(text), "%.1f%%/°C", id(temp_rate_percent));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 340
                  y: 70
              - button:
                  x: 410
                  y: 70
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: temp_rate_input
                      - lvgl.label.update:
                          id: temp_rate_display
                          text: !lambda |-
                            static char text[15];
                            snprintf(text, sizeof(text), "%.1f%%/°C", id(temp_rate_percent));
                            return text;

        # Center Time and Runtime Blocks
        - obj:
            scrollable: false
            width: 480
            height: 100
            bg_color: 0x000000
            bg_opa: 50%
            radius: 0
            x: 0
            y: 190
            border_width: 0
            widgets:
              - label:
                  text: "Center Time & Runtime Blocks"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 0
                  y: 5

              # Center Time
              - label:
                  text: "Center time:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 0
                  y: 35
              - button:
                  x: 100
                  y: 30
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: center_time_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: center_time_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:00", id(center_pump_time_hour));
                            return text;
              - label:
                  id: center_time_display
                  text: !lambda |-
                    static char text[10];
                    snprintf(text, sizeof(text), "%02d:00", id(center_pump_time_hour));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 135
                  y: 35
              - button:
                  x: 180
                  y: 30
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: center_time_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: center_time_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:00", id(center_pump_time_hour));
                            return text;

              # Runtime Blocks
              - label:
                  text: "Runtime blocks "
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 215
                  y: 35
              - button:
                  x: 345
                  y: 30
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: runtime_blocks_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: runtime_blocks_display
                          text: !lambda |-
                            static char text[5];
                            snprintf(text, sizeof(text), "%d", id(pump_runtime_blocks));
                            return text;
                      - if:
                          condition:
                            lambda: "return id(pump_runtime_blocks) >= 2;"
                          then:
                            - lvgl.widget.show: free_block2_settings
                          else:
                            - lvgl.widget.hide: free_block2_settings
                      - if:
                          condition:
                            lambda: "return id(pump_runtime_blocks) >= 3;"
                          then:
                            - lvgl.widget.show: free_block3_settings
                          else:
                            - lvgl.widget.hide: free_block3_settings
                      - if:
                          condition:
                            lambda: "return id(pump_runtime_blocks) >= 4;"
                          then:
                            - lvgl.widget.show: free_block4_settings
                          else:
                            - lvgl.widget.hide: free_block4_settings
                      - lvgl.label.update:
                          id: runtime_info_display
              - label:
                  id: runtime_blocks_display
                  text: !lambda |-
                    static char text[5];
                    snprintf(text, sizeof(text), "%d", id(pump_runtime_blocks));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 380
                  y: 35
              - button:
                  x: 400
                  y: 30
                  width: 30
                  height: 25
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: runtime_blocks_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: runtime_blocks_display
                          text: !lambda |-
                            static char text[5];
                            snprintf(text, sizeof(text), "%d", id(pump_runtime_blocks));
                            return text;
                      - if:
                          condition:
                            lambda: "return id(pump_runtime_blocks) >= 2;"
                          then:
                            - lvgl.widget.show: free_block2_settings
                          else:
                            - lvgl.widget.hide: free_block2_settings
                      - if:
                          condition:
                            lambda: "return id(pump_runtime_blocks) >= 3;"
                          then:
                            - lvgl.widget.show: free_block3_settings
                          else:
                            - lvgl.widget.hide: free_block3_settings
                      - if:
                          condition:
                            lambda: "return id(pump_runtime_blocks) >= 4;"
                          then:
                            - lvgl.widget.show: free_block4_settings
                          else:
                            - lvgl.widget.hide: free_block4_settings
                      - lvgl.label.update:
                          id: runtime_info_display

              # Runtime Info Display
              - label:
                  id: runtime_info_display
                  #hidden: true
                  text: !lambda |-
                    static char text[80];
                    int blocks = id(pump_runtime_blocks);
                    int center_runtime = id(calculated_daily_runtime) / blocks;
                    int free_runtime = (blocks > 1) ? id(calculated_daily_runtime) / blocks : 0;

                    if (blocks == 1) {
                      snprintf(text, sizeof(text), "1 Run: All %d min centered at %02d:00", 
                               id(calculated_daily_runtime), id(center_pump_time_hour));
                    } else {
                      snprintf(text, sizeof(text), "%d Runs: Center %d min, Free blocks %d min each", 
                               blocks, center_runtime, free_runtime);
                    }
                    return text;
                  text_font: roboto
                  text_color: 0x00FF00
                  x: 5
                  y: 60

        # Free Block 2 Settings (only show if blocks >= 2)
        - obj:
            id: free_block2_settings
            scrollable: false
            width: 460
            height: 60
            bg_color: 0x000000
            bg_opa: 50%
            radius: 0
            x: 10
            y: 295
            border_width: 0
            hidden: !lambda "return id(pump_runtime_blocks) < 2;"
            widgets:
              - label:
                  text: "Block 2 Start Time"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 10
                  y: 10
              - button:
                  x: 200
                  y: 10
                  width: 30
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: free_block2_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block2_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block2_start_hour), id(free_block2_start_minute));
                            return text;
              - label:
                  id: free_block2_display
                  text: !lambda |-
                    static char text[10];
                    snprintf(text, sizeof(text), "%02d:%02d", id(free_block2_start_hour), id(free_block2_start_minute));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 235
                  y: 15
              - button:
                  x: 280
                  y: 10
                  width: 30
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: free_block2_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block2_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block2_start_hour), id(free_block2_start_minute));
                            return text;
              - button:
                  x: 340
                  y: 10
                  width: 25
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "-"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - number.decrement: free_block2_minute_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block2_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block2_start_hour), id(free_block2_start_minute));
                            return text;
              - button:
                  x: 375
                  y: 10
                  width: 25
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "+"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - number.increment: free_block2_minute_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block2_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block2_start_hour), id(free_block2_start_minute));
                            return text;

        # Free Block 3 Settings (only show if blocks >= 3)
        - obj:
            id: free_block3_settings
            scrollable: false
            width: 460
            height: 60
            bg_color: 0x000000
            bg_opa: 50%
            radius: 0
            border_width: 0
            x: 10
            y: 355
            hidden: !lambda "return id(pump_runtime_blocks) < 3;"
            widgets:
              - label:
                  text: "Block 3 Start Time"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 10
                  y: 10
              - button:
                  x: 200
                  y: 10
                  width: 30
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: free_block3_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block3_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block3_start_hour), id(free_block3_start_minute));
                            return text;
              - label:
                  id: free_block3_display
                  text: !lambda |-
                    static char text[10];
                    snprintf(text, sizeof(text), "%02d:%02d", id(free_block3_start_hour), id(free_block3_start_minute));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 235
                  y: 15
              - button:
                  x: 280
                  y: 10
                  width: 30
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: free_block3_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block3_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block3_start_hour), id(free_block3_start_minute));
                            return text;
              - button:
                  x: 340
                  y: 10
                  width: 25
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "-"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - number.decrement: free_block3_minute_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block3_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block3_start_hour), id(free_block3_start_minute));
                            return text;
              - button:
                  x: 375
                  y: 10
                  width: 25
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "+"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - number.increment: free_block3_minute_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block3_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block3_start_hour), id(free_block3_start_minute));
                            return text;

        # Free Block 4 Settings (only show if blocks >= 4)
        - obj:
            id: free_block4_settings
            scrollable: false
            width: 460
            height: 60
            bg_color: 0x000000
            bg_opa: 50%
            radius: 0
            border_width: 0
            x: 10
            y: 415
            hidden: !lambda "return id(pump_runtime_blocks) < 4;"
            widgets:
              - label:
                  text: "Block 4 Start Time"
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 10
                  y: 10
              - button:
                  x: 200
                  y: 10
                  width: 30
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: free_block4_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block4_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block4_start_hour), id(free_block4_start_minute));
                            return text;
              - label:
                  id: free_block4_display
                  text: !lambda |-
                    static char text[10];
                    snprintf(text, sizeof(text), "%02d:%02d", id(free_block4_start_hour), id(free_block4_start_minute));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 235
                  y: 15
              - button:
                  x: 280
                  y: 10
                  width: 30
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: free_block4_hour_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block4_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block4_start_hour), id(free_block4_start_minute));
                            return text;
              - button:
                  x: 340
                  y: 10
                  width: 25
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "-"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - number.decrement: free_block4_minute_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block4_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block4_start_hour), id(free_block4_start_minute));
                            return text;
              - button:
                  x: 375
                  y: 10
                  width: 25
                  height: 25
                  pad_all: 0
                  widgets:
                    - label:
                        text: "+"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - number.increment: free_block4_minute_input
                      - delay: 50ms
                      - lvgl.label.update:
                          id: free_block4_display
                          text: !lambda |-
                            static char text[10];
                            snprintf(text, sizeof(text), "%02d:%02d", id(free_block4_start_hour), id(free_block4_start_minute));
                            return text;

        # Current Status Display
        - obj:
            scrollable: false
            hidden: true
            width: 460
            height: 100
            bg_color: 0x000000
            bg_opa: 50%
            radius: 10
            x: 10
            y: 490
            widgets:
              - label:
                  text: "Current Status"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 10
                  y: 5
              - label:
                  id: current_status_display
                  text: !lambda |-
                    static char text[200];
                    auto now = id(time_comp).now();

                    // Calculate today's runtime
                    int daily_runtime = id(calculated_daily_runtime);
                    if (daily_runtime == 0) {
                      // Trigger calculation if not done yet
                      return "Calculating runtime...";
                    }

                    int center_runtime = daily_runtime / id(pump_runtime_blocks);
                    int free_runtime = (id(pump_runtime_blocks) > 1) ? daily_runtime / id(pump_runtime_blocks) : 0;

                    snprintf(text, sizeof(text), 
                             "Today: %d min total\nCenter block: %d min (%02d:00 ±%d min)\nFree blocks: %d min each\nTemp: %.1f°C (ref: %.1f°C)", 
                             daily_runtime, 
                             center_runtime, 
                             id(center_pump_time_hour), 
                             center_runtime/2,
                             free_runtime,
                             id(owm_temperature).has_state() ? id(owm_temperature).state : 0.0,
                             id(reference_temperature));
                    return text;
                  text_font: roboto
                  text_color: 0x00FFFF
                  x: 10
                  y: 30

        # Control Buttons
        - obj:
            scrollable: false
            width: 460
            height: 80
            bg_color: 0x000000
            bg_opa: 50%
            radius: 10
            x: 10
            y: 600
            hidden: true
            widgets:
              # Auto irrigation toggle
              - button:
                  id: auto_irrigation_toggle
                  x: 10
                  y: 20
                  width: 150
                  height: 40
                  checkable: true
                  state:
                    checked: !lambda "return id(auto_irrigation_enabled);"
                  widgets:
                    - label:
                        id: auto_irrigation_label
                        text: !lambda |-
                          if (id(auto_irrigation_enabled)) {
                            return "Auto: ON";
                          } else {
                            return "Auto: OFF";
                          }
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          id(auto_irrigation_enabled) = !id(auto_irrigation_enabled);
                      - if:
                          condition:
                            lambda: "return id(auto_irrigation_enabled);"
                          then:
                            - lvgl.label.update:
                                id: auto_irrigation_label
                                text: "Auto: ON"
                          else:
                            - lvgl.label.update:
                                id: auto_irrigation_label
                                text: "Auto: OFF"

              # Calculate button
              - button:
                  id: calculate_button
                  x: 170
                  y: 20
                  width: 80
                  height: 40
                  widgets:
                    - label:
                        text: "Calc"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - script.execute: calculate_irrigation_needs
                      - lvgl.widget.update:
                          id: current_status_display
                      - lvgl.widget.update:
                          id: runtime_info_display

              # Test button
              - button:
                  id: test_irrigation_button
                  x: 260
                  y: 20
                  width: 80
                  height: 40
                  widgets:
                    - label:
                        text: "Test"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - script.execute: calculate_irrigation_needs
                      - lambda: |-
                          ESP_LOGI("irrigation", "Manual test irrigation triggered");
                          id(irrigation_duration_remaining) = 5; // 5 minute test
                      - switch.turn_on: sw3 # Irrigation Valve
                      - delay: 2s
                      - switch.turn_on: sw2 # Water Pump
                      - while:
                          condition:
                            lambda: "return id(irrigation_duration_remaining) > 0;"
                          then:
                            - delay: 60s
                            - lambda: |-
                                id(irrigation_duration_remaining)--;
                                ESP_LOGD("irrigation", "Test remaining: %d minutes", id(irrigation_duration_remaining));
                      - switch.turn_off: sw2
                      - switch.turn_off: sw3

              # Done button
              - button:
                  id: back_back_button
                  x: 350
                  y: 20
                  width: 100
                  height: 40
                  bg_color: 0x00FF00
                  styles: nav_button_style
                  widgets:
                    - label:
                        text: "Done"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          // go to main page from settings page
                          id(lvgl_comp).show_page(1, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);

    # Settings Page
    - id: settings_page
      bg_color: 0x000000
      bg_opa: cover
      pad_all: 0
      border_width: 0
      scrollable: false
      widgets:
        # Background image for settings page
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT
        # Title bar
        - obj:
            width: 460
            height: 50
            bg_color: 0x1E3A8A
            bg_opa: 80%
            radius: 10
            scrollable: false
            x: 10
            y: 10
            widgets:
              - label:
                  text: "DEVICE INTERNET SETTINGS"
                  text_font: roboto24
                  align: center
                  text_color: 0xFFFFFF
                  x: 0
                  y: 2
                  scrollable: false
                # QR Code settings container (replaces location settings)
        - obj:
            width: 460
            height: 120
            bg_color: 0x000000
            bg_opa: 0%
            border_width: 0
            scrollable: false
            radius: 10
            x: 10
            y: 50
            widgets:
              - label:
                  text: "Scan QR Code"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 10
                  y: 0
                  align: center
              - label:
                  text: "configure device via web:"
                  text_font: roboto
                  x: 10
                  y: 30
                  text_color: 0xFFFFFF
                  align: center

              - label:
                  id: qr_url_label
                  text: !lambda |-
                    if (id(ip_address).has_state() && !id(ip_address).state.empty()) {
                      std::string raw = id(ip_address).state;
                      std::string clean_ip = "";
                      
                      // Extract only digits and dots
                      bool found_digit = false;
                      for (char c : raw) {
                        if (std::isdigit(c)) {
                          clean_ip += c;
                          found_digit = true;
                        } else if (c == '.' && found_digit) {
                          clean_ip += c;
                        } else if (found_digit && !std::isdigit(c) && c != '.') {
                          break;
                        }
                      }
                      
                      // Validate IP format
                      int dot_count = std::count(clean_ip.begin(), clean_ip.end(), '.');
                      if (dot_count == 3 && clean_ip.length() >= 7 && clean_ip.length() <= 15) {
                        return "http://" + clean_ip;
                      }
                    }
                    return "Waiting for IP address...";
                  text_font: roboto
                  x: 90
                  y: 50
                  text_color: 0xFFFFFF
                  width: 320
                  align: center
        - obj:
            width: 460
            height: 200
            bg_color: 0x000000
            bg_opa: 0%
            border_width: 0
            scrollable: false
            radius: 10
            x: 10
            y: 190
            widgets:
              - qrcode:
                  id: settings_qr
                  align: center
                  x: 5
                  y: 20
                  border_width: 10
                  border_color: 0xFFFFFF
                  light_color: whitesmoke
                  dark_color: steelblue
                  size: 150
                  text: !lambda |-
                    if (id(ip_address).has_state() && !id(ip_address).state.empty()) {
                     return "phijo-smart-device.local/";
                    }
                    return "http://192.168.4.1/";

        - button:
            id: valve_training_btn
            x: 295
            y: 420
            hidden: false
            width: 120
            height: 45
            styles: nav_button_style
            widgets:
              - label:
                  text: !lambda |-
                    if (id(valve_training_mode)) {
                      return "Training...";
                    }
                    return "Train Valve";
                  text_font: roboto
                  align: center
                  text_color: !lambda |-
                    if (id(valve_training_mode)) {
                      return lv_color_hex(0xFFA500);  // Orange
                    }
                    return lv_color_hex(0xCCCCCC);  // GREY
                  on_click:
                    then:
                      - script.execute: start_valve_training

        # Bucket volume controls for valve calibration
        - obj:
            x: 150
            y: 420
            width: 130
            height: 45
            bg_opa: 0%
            border_width: 0
            widgets:
              - label:
                  id: bucket_volume_label
                  text: !lambda |-
                    static char t[24];
                    snprintf(t, sizeof(t), "Bucket: %.1fL", id(bucket_volume_liters));
                    return t;
                  text_font: roboto
                  align: LEFT_MID
              - button:
                  x: 0
                  y: 0
                  width: 25
                  height: 25
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          id(bucket_volume_liters) = std::max(1.0f, id(bucket_volume_liters) - 1.0f);
                      - lvgl.label.update:
                          id: bucket_volume_label
              - button:
                  x: 30
                  y: 0
                  width: 25
                  height: 25
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          id(bucket_volume_liters) = std::min(100.0f, id(bucket_volume_liters) + 1.0f);
                      - lvgl.label.update:
                          id: bucket_volume_label

        # Navigation buttons
        - button:
            id: home_button
            x: 30
            y: 420
            width: 120
            height: 45
            styles: nav_button_style
            widgets:
              - label:
                  text: "Back"
                  text_font: roboto
                  align: center
            on_click:
              then:
                #- lvgl.page.previous:
                - lambda: |-
                    // go to settings page from control page
                    id(current_page)=1;
                    id(lvgl_comp).show_page(1, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);

        # Light Automation Settings Page
    - id: light_settings_page
      bg_color: 0x000000
      bg_opa: cover
      pad_all: 0
      border_width: 0
      scrollable: false
      widgets:
        # Background image
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT

        # Title bar
        - obj:
            width: 460
            height: 50
            bg_color: 0x1E3A8A
            bg_opa: 0%
            radius: 10
            scrollable: false
            x: 10
            y: 10
            widgets:
              - label:
                  text: "LIGHT SETTINGS"
                  text_font: roboto24
                  align: center
                  text_color: 0xFFFFFF
                  scrollable: false
                  x: 0
                  y: 0
                  on_click:
                    then:
                      - lvgl.page.previous:
                      - lambda: |-
                          id(current_page) = 1;  // Set current page to settings

        # Sunset Settings
        - obj:
            width: 460
            height: 120
            bg_color: 0x000000
            bg_opa: 50%
            radius: 10
            scrollable: false
            x: 10
            y: 70
            widgets:
              - label:
                  text: "Sunset Settings"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 10
                  y: -5

              # Sunset duration setting
              - label:
                  text: "Light on after sunset for:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 35
              - button:
                  id: sunset_hours_minus
                  x: 250
                  y: 30
                  width: 40
                  height: 30
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: sunset_hours_input
                      - lvgl.label.update:
                          id: sunset_hours_display
                          text: !lambda |-
                            static char text[20];
                            snprintf(text, sizeof(text), "%d hours", id(sunset_duration_hours));
                            return text;
              - label:
                  id: sunset_hours_display
                  text: !lambda |-
                    static char text[20];
                    snprintf(text, sizeof(text), "%d hours", id(sunset_duration_hours));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 300
                  y: 35
              - button:
                  id: sunset_hours_plus
                  x: 380
                  y: 30
                  width: 40
                  height: 30
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: sunset_hours_input
                      - lvgl.label.update:
                          id: sunset_hours_display
                          text: !lambda |-
                            static char text[20];
                            snprintf(text, sizeof(text), "%d hours", id(sunset_duration_hours));
                            return text;

              # Until time setting
              - label:
                  text: "Or until time:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 70
              - button:
                  id: until_hour_minus
                  x: 150
                  y: 65
                  width: 30
                  height: 30
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: until_time_hour_input
                      - lvgl.label.update:
                          id: until_time_display
                          text: !lambda |-
                            static char text[20];
                            // if the set number is less than 10, add a leading zero and make sure its within 0 to 24 hours
                            if ((id(sunset_until_time_hour) < 10) && (id(sunset_until_time_hour) >= 0) 
                                && (id(sunset_until_time_hour) < 24)) {
                              snprintf(text, sizeof(text), "0%d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            } else {
                              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            }
                            return text;
              - label:
                  id: until_time_display
                  text: !lambda |-
                    static char text[20];
                    snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 190
                  y: 70
              - button:
                  id: until_hour_plus
                  x: 250
                  y: 65
                  width: 30
                  height: 30
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: until_time_hour_input
                      - lvgl.label.update:
                          id: until_time_display
                          text: !lambda |-
                            static char text[20];
                            // if the set number is less than 10, add a leading zero and make sure its within 0 to 24 hours
                            if ((id(sunset_until_time_hour) < 10) && (id(sunset_until_time_hour) >= 0) 
                                && (id(sunset_until_time_hour) < 24)) {
                              snprintf(text, sizeof(text), "0%d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            } else {
                              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            }
                            return text;
              - button:
                  id: until_minute_minus
                  x: 290
                  y: 65
                  width: 30
                  height: 30
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: until_time_minute_input
                      - lvgl.label.update:
                          id: until_time_display
                          text: !lambda |-
                            static char text[20];
                            // if the set number is less than 10, add a leading zero and make sure its within 0 to 24 hours
                            if ((id(sunset_until_time_minute) < 10) && (id(sunset_until_time_minute) >= 0) 
                                && (id(sunset_until_time_minute) < 60)) {
                              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            } else {
                              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            }
                            return text;
              - button:
                  id: until_minute_plus
                  x: 330
                  y: 65
                  width: 30
                  height: 30
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: until_time_minute_input
                      - lvgl.label.update:
                          id: until_time_display
                          text: !lambda |-
                            static char text[20];
                            // if the set number is less than 10, add a leading zero and make sure its within 0 to 24 hours
                            if ((id(sunset_until_time_minute) < 10) && (id(sunset_until_time_minute) >= 0) 
                                && (id(sunset_until_time_minute) < 60)) {
                              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            } else {
                              snprintf(text, sizeof(text), "%02d:%02d", id(sunset_until_time_hour), id(sunset_until_time_minute));
                            }
                            return text;

        # Sunrise Settings
        - obj:
            width: 460
            height: 80
            bg_color: 0x000000
            bg_opa: 50%
            radius: 10
            scrollable: false
            x: 10
            y: 200
            widgets:
              - label:
                  text: "Sunrise  Settings"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 10
                  y: -5

              - label:
                  text: "Light on before sunrise for:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 35
              - button:
                  id: sunrise_hours_minus
                  x: 250
                  y: 30
                  width: 40
                  height: 30
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: sunrise_hours_input
                      - lvgl.label.update:
                          id: sunrise_hours_display
                          text: !lambda |-
                            static char text[20];
                            snprintf(text, sizeof(text), "%d hours", id(sunrise_duration_hours));
                            return text;
              - label:
                  id: sunrise_hours_display
                  text: !lambda |-
                    static char text[20];
                    snprintf(text, sizeof(text), "%d hours", id(sunrise_duration_hours));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 300
                  y: 35
              - button:
                  id: sunrise_hours_plus
                  x: 380
                  y: 30
                  width: 40
                  height: 30
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: sunrise_hours_input
                      - lvgl.label.update:
                          id: sunrise_hours_display
                          text: !lambda |-
                            static char text[20];
                            snprintf(text, sizeof(text), "%d hours", id(sunrise_duration_hours));
                            return text;

        # Manual Settings
        - obj:
            width: 460
            height: 80
            bg_color: 0x000000
            bg_opa: 50%
            radius: 10
            scrollable: false
            x: 10
            y: 290
            widgets:
              - label:
                  text: "Manual Control Settings"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  scrollable: false
                  x: 10
                  y: -5

              - label:
                  text: "Manual on duration:"
                  text_font: roboto
                  text_color: 0xCCCCCC
                  x: 10
                  y: 35
              - button:
                  id: manual_hours_minus
                  x: 250
                  y: 30
                  width: 40
                  height: 30
                  widgets:
                    - label:
                        text: "-"
                        align: center
                  on_click:
                    then:
                      - number.decrement: manual_hours_input
                      - lvgl.label.update:
                          id: manual_hours_display
                          text: !lambda |-
                            static char text[20];
                            snprintf(text, sizeof(text), "%d hours", id(manual_duration_hours));
                            return text;
              - label:
                  id: manual_hours_display
                  text: !lambda |-
                    static char text[20];
                    snprintf(text, sizeof(text), "%d hours", id(manual_duration_hours));
                    return text;
                  text_font: roboto
                  text_color: 0xFFFFFF
                  x: 300
                  y: 35
              - button:
                  id: manual_hours_plus
                  x: 380
                  y: 30
                  width: 40
                  height: 30
                  widgets:
                    - label:
                        text: "+"
                        align: center
                  on_click:
                    then:
                      - number.increment: manual_hours_input
                      - lvgl.label.update:
                          id: manual_hours_display
                          text: !lambda |-
                            static char text[20];
                            snprintf(text, sizeof(text), "%d hours", id(manual_duration_hours));
                            return text;

        # Mode Selection
        - obj:
            width: 460
            height: 100
            bg_color: 0x000000
            bg_opa: 50%
            radius: 10
            x: 10
            y: 380
            scrollable: false
            widgets:
              - label:
                  text: "Automation Mode"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 10
                  y: -5
              - button:
                  id: mode_duration_btn
                  x: 10
                  y: 35
                  width: 100
                  height: 30
                  checkable: true
                  widgets:
                    - label:
                        text: "Duration"
                        align: center
                        text_font: roboto
                  on_click:
                    then:
                      - lambda: |-
                          // If already in Duration mode, deselect and turn off light
                          if (id(automation_mode) == 0) {
                            id(automation_mode) = -1; // No mode selected
                            id(sw1).turn_off();
                            id(sw1_off_time) = 0;
                            ESP_LOGI("automation", "No automation mode selected: Light turned OFF");
                            return;
                          }
                          // If leaving Manual mode, turn light off
                          if (id(automation_mode) == 3) {
                            id(sw1).turn_off();
                            ESP_LOGI("automation", "Left Manual mode: Light turned OFF");
                          }
                          id(automation_mode) = 0;
                      - lvgl.widget.update:
                          id: mode_duration_btn
                          state:
                            checked: !lambda "return id(automation_mode) == 0;"
                      - lvgl.widget.update:
                          id: mode_until_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_between_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_manual_btn
                          state:
                            checked: false

              - button:
                  id: mode_until_btn
                  x: 120
                  y: 35
                  width: 100
                  height: 30
                  checkable: true
                  widgets:
                    - label:
                        text: "Until Time"
                        align: center
                        text_font: roboto
                  on_click:
                    then:
                      - lambda: |-
                          // If already in Until Time mode, deselect and turn off light
                          if (id(automation_mode) == 1) {
                            id(automation_mode) = -1; // No mode selected
                            id(sw1).turn_off();
                            id(sw1_off_time) = 0;
                            ESP_LOGI("automation", "No automation mode selected: Light turned OFF");
                            return;
                          }
                          // If leaving Manual mode, turn light off
                          if (id(automation_mode) == 3) {
                            id(sw1).turn_off();
                            ESP_LOGI("automation", "Left Manual mode: Light turned OFF");
                          }
                          id(automation_mode) = 1;
                      - lvgl.widget.update:
                          id: mode_duration_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_until_btn
                          state:
                            checked: !lambda "return id(automation_mode) == 1;"
                      - lvgl.widget.update:
                          id: mode_between_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_manual_btn
                          state:
                            checked: false

              - button:
                  id: mode_between_btn
                  x: 230
                  y: 35
                  width: 100
                  height: 30
                  checkable: true
                  widgets:
                    - label:
                        text: "Between"
                        align: center
                        text_font: roboto
                  on_click:
                    then:
                      - lambda: |-
                          // If already in Between Times mode, deselect and turn off light
                          if (id(automation_mode) == 2) {
                            id(automation_mode) = -1; // No mode selected
                            id(sw1).turn_off();
                            id(sw1_off_time) = 0;
                            ESP_LOGI("automation", "No automation mode selected: Light turned OFF");
                            return;
                          }
                          // If leaving Manual mode, turn light off
                          if (id(automation_mode) == 3) {
                            id(sw1).turn_off();
                            ESP_LOGI("automation", "Left Manual mode: Light turned OFF");
                          }
                          id(automation_mode) = 2;
                      - lvgl.widget.update:
                          id: mode_duration_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_until_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_between_btn
                          state:
                            checked: !lambda "return id(automation_mode) == 2;"
                      - lvgl.widget.update:
                          id: mode_manual_btn
                          state:
                            checked: false
              - button:
                  id: mode_manual_btn
                  x: 230
                  y: 0
                  width: 100
                  height: 30
                  checkable: true
                  widgets:
                    - label:
                        text: "Manual"
                        align: center
                        text_font: roboto
                  on_click:
                    then:
                      - lambda: |-
                          // If already in Manual mode, deselect and turn off light
                          if (id(automation_mode) == 3) {
                            id(automation_mode) = -1; // No mode selected
                            id(sw1).turn_off();
                            id(sw1_off_time) = 0;
                            ESP_LOGI("automation", "No automation mode selected: Light turned OFF");
                            return;
                          }
                          
                          id(automation_mode) = 3;
                          
                          // Turn light ON immediately in Manual mode and set timer
                          auto now = id(sntp_time).now();
                          if (now.is_valid()) {
                            id(sw1).turn_on();
                            id(sw1_off_time) = now.timestamp + (id(manual_duration_hours) * 3600);
                            id(sw1_manual_override_time) = 0; // Clear override so timer works
                            ESP_LOGI("automation", "Manual mode selected: Light ON, auto-off in %d hours", id(manual_duration_hours));
                          }
                      - lvgl.widget.update:
                          id: mode_duration_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_until_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_between_btn
                          state:
                            checked: false
                      - lvgl.widget.update:
                          id: mode_manual_btn
                          state:
                            checked: !lambda "return id(automation_mode) == 3;"
                           
                      - lvgl.widget.update:
                          id: mode_between_btn
                          state:
                            checked: false

              - button:
                  id: back_manual_btn
                  x: 340
                  y: 0
                  width: 100
                  height: 30
                  bg_color: 0x00FF00
                  #checkable: true
                  widgets:
                    - label:
                        text: "Done"
                        align: center
                        text_font: roboto
                  on_click:
                    then:
                      - lambda: |-
                          // go to sttong page from control page
                          id(lvgl_comp).show_page(1, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);

    - id: water_pump_settings_page
      bg_color: 0x000000
      #bg_opa: cover
      pad_all: 0
      border_width: 0
      scrollable: true
      widgets:
        # Background image
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT

        # Title bar
        - obj:
            width: 460
            height: 50
            bg_color: 0x1E3A8A
            bg_opa: 80%
            radius: 10
            x: 10
            y: 10
            scrollable: false
            widgets:
              - label:
                  text: "VALVE SETTINGS - WATER FILL/RELEASE"
                  text_font: roboto24
                  align: center
                  text_color: 0xFFFFFF
                  border_width: 0
                  x: 0
                  y: 5
                  scrollable: false
                  on_click:
                    then:
                      - lvgl.page.previous:
                      - lambda: |-
                          id(current_page) = 1;  // Set current page to controll settings

        # WaterCalculations Section
        - obj:
            scrollable: false
            width: 460
            height: 160
            #bg_color: 0x000000
            bg_opa: 40%
            radius: 10
            x: 10
            y: 70
            widgets:
              - label:
                  text: "Daily Water Calculations"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 10
                  y: 5
              - label:
                  text: "Evaporation:"
                  text_font: roboto
                  x: 10
                  y: 35
                  text_color: 0xFFFFFF
              - label:
                  id: evaporation_display
                  text: !lambda |-
                    static char evap_text[40];
                    snprintf(evap_text, sizeof(evap_text), "%.1f L/day", id(calculated_evaporation_liters));
                    return evap_text;
                  text_font: roboto
                  x: 120
                  y: 35
                  text_color: 0xFFFFFF
              - label:
                  text: "Rainfall:"
                  text_font: roboto
                  x: 10
                  y: 60
                  text_color: 0xFFFFFF
              - label:
                  id: rainfall_display
                  text: !lambda |-
                    static char rain_text[40];
                    float rainfall_liters = id(daily_rainfall_mm) * id(field_area_m2) / 1000.0;
                    snprintf(rain_text, sizeof(rain_text), "%.1f L (%.1f mm)", rainfall_liters, id(daily_rainfall_mm));
                    return rain_text;
                  text_font: roboto
                  x: 80
                  y: 60
                  text_color: 0xFFFFFF
              - label:
                  text: "Today :"
                  text_font: roboto
                  x: 10
                  y: 85
                  text_color: 0xFFFFFF
              - label:
                  id: irrigation_needed_display
                  text: !lambda |-
                    static char need_text[50];
                    if (id(irrigation_needed_liters) > 0) {
                      float minutes_needed = id(irrigation_needed_liters) / id(valve_liters_per_minute);
                      snprintf(need_text, sizeof(need_text), "%.1f L (%.1f min)", 
                              id(irrigation_needed_liters), minutes_needed);
                    } else {
                      snprintf(need_text, sizeof(need_text), "0 L (No Water needed)");
                    }
                    return need_text;
                  text_font: roboto
                  x: 80
                  y: 85
                  text_color: !lambda |-
                    if (id(irrigation_needed_liters) > 0) {
                      return lv_color_hex(0xFFA500);  // Orange
                    }
                    return lv_color_hex(0x000000);  //  - no Water needed
              - label:
                  text: "Mode:"
                  text_font: roboto
                  x: 10
                  y: 110
                  text_color: 0xCCCCCC
              - label:
                  id: irrigation_mode_display
                  text: !lambda |-
                    if (id(sw3_winter_mode)) {
                      return "Winter (Low evaporation)";
                    } else {
                      return "Summer (High evaporation)";
                    }
                  text_font: roboto
                  x: 60
                  y: 110
                  text_color: 0xFFFFFF
        # SW3 Mode Toggle
        - button:
            id: sw3_mode_toggle
            width: 460
            height: 60
            x: 10
            y: 230
            checkable: true
            state:
              checked: !lambda "return id(sw3_winter_mode);"
            widgets:
              - label:
                  id: sw3_mode_label
                  text: !lambda |-
                    if (id(sw3_winter_mode)) {
                      return "Valve: Winter (Rain-based)";
                    } else {
                      return "Valve: Summer (Temperature-based)";
                    }
                  text_font: roboto
                  align: center
            on_click:
              then:
                - lambda: |-
                    id(sw3_winter_mode) = !id(sw3_winter_mode);
                - script.execute: calculate_irrigation_needs
                - if:
                    condition:
                      lambda: "return id(sw3_winter_mode);"
                    then:
                      - lvgl.label.update:
                          id: sw3_mode_label
                          text: "Valve: Winter (Rain-based)"
                      - lvgl.label.update:
                          id: sw3_button_label
                          text: "Valve (Winter)"
                      - lvgl.label.update:
                          id: season_mode_label
                          text: "Winter Mode"
                      - lvgl.widget.update:
                          id: winter_summer_toggle
                          state:
                            checked: true
                    else:
                      - lvgl.label.update:
                          id: sw3_mode_label
                          text: "Summer (Temperature-based)"
                      - lvgl.label.update:
                          id: sw3_button_label
                          text: "Valve (Summer)"
                      - lvgl.label.update:
                          id: season_mode_label
                          text: "Summer Mode"
                      - lvgl.widget.update:
                          id: winter_summer_toggle
                          state:
                            checked: false
        # Weather Impact Section
        - obj:
            width: 460
            height: 110
            bg_color: 0x000000
            bg_opa: 0%
            scrollable: false
            border_width: 0
            radius: 10
            x: 10
            y: 300
            widgets:
              - label:
                  text: "Weather Impact"
                  text_font: roboto24
                  text_color: 0xFFFFFF
                  x: 10
                  y: 0
              - label:
                  id: weather_recommendation
                  text: !lambda |-
                    if (id(irrigation_needed_liters) > 20) {
                      return " High Water needs - Check valve operation";
                    } else if (id(irrigation_needed_liters) > 5) {
                      return " Moderate Water recommended";
                    } else if (id(daily_rainfall_mm) > 10) {
                      return " Recent rainfall - Water not needed";
                    } else {
                      return " Water levels optimal";
                    }
                  text_font: roboto
                  x: 10
                  y: 30
                  text_color: 0xFFFFFF
                  width: 440

        # Control Buttons Section
        - obj:
            width: 460
            height: 100
            bg_color: 0x000000
            bg_opa: 0%
            radius: 10
            scrollable: false
            border_width: 0
            x: 10
            y: 350
            widgets:
              - button:
                  id: winter_summer_toggle
                  x: 2
                  y: 10
                  width: 150
                  height: 60
                  checkable: true
                  state:
                    checked: !lambda "return id(sw3_winter_mode);"
                  widgets:
                    - label:
                        id: season_mode_label
                        text: !lambda |-
                          if (id(sw3_winter_mode)) {
                            return "Winter Mode";
                          } else {
                            return "Summer Mode";
                          }
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          id(sw3_winter_mode) = !id(sw3_winter_mode);
                      - script.execute: calculate_irrigation_needs
                      - if:
                          condition:
                            lambda: "return id(sw3_winter_mode);"
                          then:
                            - lvgl.label.update:
                                id: season_mode_label
                                text: "Winter Mode"
                            - lvgl.label.update:
                                id: sw3_mode_label
                                text: "Valve: Winter (Rain-based)"
                            - lvgl.label.update:
                                id: sw3_button_label
                                text: "Valve (Winter)"
                            - lvgl.widget.update:
                                id: sw3_mode_toggle
                                state:
                                  checked: true
                          else:
                            - lvgl.label.update:
                                id: season_mode_label
                                text: "Summer Mode"
                            - lvgl.label.update:
                                id: sw3_mode_label
                                text: "Summer (Temperature-based)"
                            - lvgl.label.update:
                                id: sw3_button_label
                                text: "Valve (Summer)"
                            - lvgl.widget.update:
                                id: sw3_mode_toggle
                                state:
                                  checked: false

              - button:
                  id: manual_irrigation_btn
                  x: 160
                  y: 10
                  width: 130
                  height: 60
                  state:
                    checked: true
                  widgets:
                    - label:
                        text: "Manual"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - switch.toggle: sw3
                      - lambda: |-
                          auto now = id(sntp_time).now();
                          if (now.is_valid()) {
                            id(sw3_manual_override_time) = now.timestamp;
                            ESP_LOGI("automation", "SW3 manual override activated for 24 hours");
                          }

              - button:
                  id: back_to_controls_btn
                  x: 300
                  y: 10
                  width: 150
                  height: 60
                  bg_color: 0x00FF00
                  widgets:
                    - label:
                        text: "Done"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          // go to sttong page from control page
                          id(lvgl_comp).show_page(1, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);

    - id: pool_pump_settings_page
      bg_color: 0x0F172A
      pad_all: 0
      border_width: 0
      scrollable: false
      widgets:
        # Optional background image
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT

        # Title bar
        - obj:
            width: 460
            height: 44
            bg_color: 0x2563EB
            bg_opa: 0%
            radius: 10
            x: 10
            y: 10
            widgets:
              - label:
                  text: "POOL PUMP SETTINGS"
                  text_font: roboto24
                  align: center
                  text_color: 0xFFFFFF
                  x: 0
                  y: 0
                  scrollable: false
              - button:
                  id: back_to_controls_btn_pool
                  x: 350
                  y: -7
                  width: 60
                  height: 30
                  bg_color: 0x00FF00
                  widgets:
                    - label:
                        text: "Done"
                        text_font: roboto
                        align: center
                  on_click:
                    then:
                      - lambda: |-
                          // go to sttong page from control page
                          id(lvgl_comp).show_page(1, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);

        # Editable settings section

        - obj:
            width: 460
            height: 380
            bg_opa: 80%
            radius: 10
            x: 10
            y: 80
            widgets:
              - label:
                  text: "Pool Dimensions / Pump Settings"
                  text_font: roboto24
                  text_color: 0x000000
                  x: 50
                  y: 0

              # Pool Length
              - label:
                  {
                    text: "Length (m):",
                    text_font: roboto,
                    x: 10,
                    y: 50,
                    text_color: 0x000000,
                  }
              - label:
                  id: pool_length_number
                  x: 170
                  y: 55
                  width: 80
                  text_color: 0x000000
                  text: !lambda |-
                    static char buf[16];
                    sprintf(buf, "%.2f", id(global_pool_length));
                    return buf;
              - button:
                  x: 230
                  y: 44
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_pool_length) += 0.1f;

                        id(pool_volume).publish_state(id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
                        float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                        float flow = id(pump_flow_rate); // m³ per hour
                        float cycles = id(global_cycles_count);

                        float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;
                        ESP_LOGI("pool_pump", "Calculated VOLUME: %.2f M3", volume);
                        ESP_LOGI("pool_pump", "Calculated FLOW: %.2f M3/h", flow);
                        ESP_LOGI("pool_pump", "Calculated CYCLES: %.2f", cycles);
                        ESP_LOGI("pool_pump", "Calculated TEMP: %.2f C", temp);

                        // Prevent divide-by-zero
                        if (flow <= 0.1f) flow = 1.0f;

                        // Temperature correction
                        float temp_factor = 1.0f;
                        if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                        else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering
                        ESP_LOGI("pool_pump", "Calculated temp factor: %.2f hours", temp_factor);
                        float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                        if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours
                        ESP_LOGI("pool_pump", "Calculated runtime: %.2f hours", runtime);
                        id(total_runtime).publish_state(runtime);
                        id(total_runtime_multiple) = runtime;
                    - script.execute: save_and_refresh_runtime
                    - globals.set:
                        id: total_runtime_multiple
                        value: !lambda "return id(total_runtime_multiple);"
                    - globals.set:
                        id: global_pool_length
                        value: !lambda "return id(global_pool_length);"
                    - lvgl.label.update:
                        id: pool_volume_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pool_volume).state);
                          return text;
                    - lvgl.label.update:
                        id: pool_length_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.2f", id(global_pool_length));
                          return text;
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          sprintf(buf, "%.1f", id(total_runtime).state);
                          return buf;
                    - lvgl.label.update:
                        id: summer_max_display
                        text: !lambda |-
                          static char text[15];
                          snprintf(text, sizeof(text), "%.2f hrs", id(total_runtime_multiple));
                          return text;

                  widgets:
                    - label: { text: "+", text_font: roboto, align: CENTER }
              - button:
                  x: 275
                  y: 44
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_pool_length) -= 0.1f;
                        if (id(global_pool_length) < 0.1) id(global_pool_length) = 0.1;
                        id(pool_volume).publish_state(id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
                        float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                        float flow = id(pump_flow_rate); // m³ per hour
                        float cycles = id(global_cycles_count);
                        float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                        // Prevent divide-by-zero
                        if (flow <= 0.1f) flow = 1.0f;

                        // Temperature correction
                        float temp_factor = 1.0f;
                        if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                        else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                        float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                        if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours
                        ESP_LOGI("pool_pump", "Calculated runtime: %.2f hours", runtime);
                        id(total_runtime).publish_state(runtime);
                        id(total_runtime_multiple) = runtime;
                    - script.execute: save_and_refresh_runtime
                    - globals.set:
                        id: global_pool_length
                        value: !lambda "return id(global_pool_length);"
                    - lvgl.label.update:
                        id: pool_volume_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pool_volume).state);
                          return text;
                    - lvgl.label.update:
                        id: pool_length_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.2f", id(global_pool_length));
                          return text;
                    - globals.set:
                        id: total_runtime_multiple
                        value: !lambda "return id(total_runtime_multiple);"
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          sprintf(buf, "%.2f", id(total_runtime).state);
                          return buf;
                  widgets:
                    - label: { text: "-", text_font: roboto, align: CENTER }

              # Pool Width
              - label:
                  {
                    text: "Width (m):",
                    text_font: roboto,
                    x: 10,
                    y: 90,
                    text_color: 0x000000,
                  }
              - label:
                  id: pool_width_number
                  x: 170
                  y: 95
                  width: 80
                  text_color: 0x000000
                  text: !lambda |-
                    static char buf[16];
                    sprintf(buf, "%.2f", id(global_pool_width));
                    return buf;
              - button:
                  x: 230
                  y: 84
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_pool_width) += 0.1f;
                        id(pool_volume).publish_state(id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
                    - globals.set:
                        id: global_pool_width
                        value: !lambda "return id(global_pool_width);"

                    - lvgl.label.update:
                        id: pool_volume_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pool_volume).state);
                          return text;
                    - lvgl.label.update:
                        id: pool_width_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.2f", id(global_pool_width));
                          return text;
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "+", text_font: roboto, align: CENTER }
              - button:
                  x: 275
                  y: 84
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_pool_width) -= 0.1f;
                        id(pool_volume).publish_state(id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
                    - globals.set:
                        id: global_pool_width
                        value: !lambda "return id(global_pool_width);"

                    - lvgl.label.update:
                        id: pool_volume_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pool_volume).state);
                          return text;
                    - lvgl.label.update:
                        id: pool_width_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.2f", id(global_pool_width));
                          return text;
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "-", text_font: roboto, align: CENTER }

              # Pool Depth
              - label:
                  {
                    text: "Depth (m):",
                    text_font: roboto,
                    x: 10,
                    y: 130,
                    text_color: 0x000000,
                  }
              - label:
                  id: pool_depth_number
                  x: 170
                  y: 135
                  width: 80
                  text_color: 0x000000
                  text: !lambda |-
                    static char buf[16];
                    sprintf(buf, "%.2f", id(global_pool_depth));
                    return buf;
              - button:
                  x: 230
                  y: 124
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_pool_depth) += 0.1f;
                        id(pool_volume).publish_state(id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
                    - globals.set:
                        id: global_pool_depth
                        value: !lambda "return id(global_pool_depth);"

                    - lvgl.label.update:
                        id: pool_volume_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pool_volume).state);
                          return text;
                    - lvgl.label.update:
                        id: pool_depth_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.2f", id(global_pool_depth));
                          return text;
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "+", text_font: roboto, align: CENTER }
              - button:
                  x: 275
                  y: 124
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_pool_depth) -= 0.1f;
                        id(pool_volume).publish_state(id(global_pool_length) * id(global_pool_width) * id(global_pool_depth));
                    - globals.set:
                        id: global_pool_depth
                        value: !lambda "return id(global_pool_depth);"

                    - lvgl.label.update:
                        id: pool_volume_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pool_volume).state);
                          return text;
                    - lvgl.label.update:
                        id: pool_depth_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.2f", id(global_pool_depth));
                          return text;
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "-", text_font: roboto, align: CENTER }

              # Pump Flow Rate
              - label:
                  {
                    text: "Flow Rate(L/H):",
                    text_font: roboto,
                    x: 10,
                    y: 170,
                    text_color: 0x000000,
                  }
              - label:
                  id: pump_flow_number
                  x: 170
                  y: 175
                  width: 80
                  text_color: 0x000000
                  text: !lambda |-
                    static char buf[16];
                    sprintf(buf, "%.1f", id(pump_flow_rate));
                    return buf;
              - button:
                  x: 230
                  y: 164
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(pump_flow_rate) += 50.0f;
                    - lvgl.label.update:
                        id: pump_flow_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pump_flow_rate));
                          return text;
                    - number.set:
                        id: "valve_flow_rate_input"
                        value: !lambda "return id(pump_flow_rate);"
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "+", text_font: roboto, align: CENTER }
              - button:
                  x: 275
                  y: 164
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(pump_flow_rate) -= 50.0f;
                        if (id(pump_flow_rate) < 0) id(pump_flow_rate) = 50.0;
                    - number.set:
                        id: "valve_flow_rate_input"
                        value: !lambda "return id(pump_flow_rate);"
                    - lvgl.label.update:
                        id: pump_flow_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(pump_flow_rate));
                          return text;
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "-", text_font: roboto, align: CENTER }

              # Number of Blocks
              - label:
                  {
                    text: "Blocks:",
                    text_font: roboto,
                    x: 10,
                    y: 210,
                    text_color: 0x000000,
                  }
              - label:
                  id: blocks_number
                  x: 170
                  y: 215
                  width: 80
                  text_color: 0x000000
                  text: !lambda |-
                    static char buf[16];
                    sprintf(buf, "%d",  id(pump_runtime_blocks));
                    return buf;
              - button:
                  x: 230
                  y: 204
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(pump_runtime_blocks) += 1;
                        if ( id(pump_runtime_blocks) > 4)  id(pump_runtime_blocks) = 4;
                        if ( id(pump_runtime_blocks) < 1)  id(pump_runtime_blocks) = 1;
                    - lvgl.label.update:
                        id: blocks_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%d",  id(pump_runtime_blocks));
                          return text;
                    - number.set:
                        id: block_number
                        value: !lambda "return id(pump_runtime_blocks);"
                    - lvgl.label.update:
                        id: runtime_blocks_display
                        text: !lambda |-
                          static char text[5];
                          snprintf(text, sizeof(text), "%d", id(pump_runtime_blocks));
                          return text;
                    # Show/hide free blocks based on blocks number
                    - if:
                        condition:
                          lambda: "return id(pump_runtime_blocks) >= 2;"
                        then:
                          - lvgl.widget.show: free_block2_settings
                        else:
                          - lvgl.widget.hide: free_block2_settings
                    - if:
                        condition:
                          lambda: "return id(pump_runtime_blocks) >= 3;"
                        then:
                          - lvgl.widget.show: free_block3_settings
                        else:
                          - lvgl.widget.hide: free_block3_settings
                    - if:
                        condition:
                          lambda: "return id(pump_runtime_blocks) >= 4;"
                        then:
                          - lvgl.widget.show: free_block4_settings
                        else:
                          - lvgl.widget.hide: free_block4_settings
                    # - lvgl.label.update:
                    #     id: runtime_info_display
                    #     text: !lambda |-
                    #       static char buf[16];
                    #       float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                    #       float flow = id(pump_flow_rate); // m³ per hour
                    #       float cycles = id(global_cycles_count);
                    #       float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                    #       // Prevent divide-by-zero
                    #       if (flow <= 0.1f) flow = 1.0f;

                    #       // Temperature correction
                    #       float temp_factor = 1.0f;
                    #       if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                    #       else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                    #       float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                    #       if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                    #       sprintf(buf, "%.1f", runtime);
                    #       id(total_runtime).publish_state(runtime);
                    #       id(total_runtime_multiple) = runtime;
                    #       return buf;
                  widgets:
                    - label: { text: "+", text_font: roboto, align: CENTER }
              - button:
                  x: 275
                  y: 204
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(pump_runtime_blocks) -= 1;
                        if ( id(pump_runtime_blocks) > 4)  id(pump_runtime_blocks) = 4;
                        if ( id(pump_runtime_blocks) < 1)  id(pump_runtime_blocks) = 1;

                    - lvgl.label.update:
                        id: blocks_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%d",  id(pump_runtime_blocks));
                          return text;
                    - number.set:
                        id: block_number
                        value: !lambda "return id(pump_runtime_blocks);"
                    - lvgl.label.update:
                        id: runtime_blocks_display
                        text: !lambda |-
                          static char text[5];
                          snprintf(text, sizeof(text), "%d", id(pump_runtime_blocks));
                          return text;
                    # Show/hide free blocks based on blocks number
                    - if:
                        condition:
                          lambda: "return id(pump_runtime_blocks) >= 2;"
                        then:
                          - lvgl.widget.show: free_block2_settings
                        else:
                          - lvgl.widget.hide: free_block2_settings
                    - if:
                        condition:
                          lambda: "return id(pump_runtime_blocks) >= 3;"
                        then:
                          - lvgl.widget.show: free_block3_settings
                        else:
                          - lvgl.widget.hide: free_block3_settings
                    - if:
                        condition:
                          lambda: "return id(pump_runtime_blocks) >= 4;"
                        then:
                          - lvgl.widget.show: free_block4_settings
                        else:
                          - lvgl.widget.hide: free_block4_settings
                    # - lvgl.label.update:
                    #     id: runtime_info_display
                    #     text: !lambda |-
                    #       static char buf[16];
                    #       float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                    #       float flow = id(pump_flow_rate); // m³ per hour
                    #       float cycles = id(global_cycles_count);
                    #       float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                    #       // Prevent divide-by-zero
                    #       if (flow <= 0.1f) flow = 1.0f;

                    #       // Temperature correction
                    #       float temp_factor = 1.0f;
                    #       if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                    #       else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                    #       float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                    #       if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                    #       sprintf(buf, "%.1f", runtime);
                    #       id(total_runtime).publish_state(runtime);
                    #       id(total_runtime_multiple) = runtime;
                    #       return buf;
                  widgets:
                    - label: { text: "-", text_font: roboto, align: CENTER }

              # Cycles
              - label:
                  {
                    text: "Cycles :",
                    text_font: roboto,
                    x: 10,
                    y: 250,
                    text_color: 0x000000,
                  }
              - label:
                  id: cycles_number
                  x: 170
                  y: 250
                  width: 80
                  hidden: false
                  text_color: 0x000000
                  text: !lambda |-
                    static char text[20];
                    snprintf(text, sizeof(text), "%.2f", id(global_cycles_count));
                    return text;
              - button:
                  x: 230
                  y: 244
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_cycles_count) += 0.5;
                        if (id(global_cycles_count) > 3) id(global_cycles_count) = 3;
                    - lvgl.label.update:
                        id: cycles_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.2f", id(global_cycles_count));
                          return text;
                    - globals.set:
                        id: cycles_count
                        value: !lambda "return id(global_cycles_count);"
                    - number.set:
                        id: cycle_number
                        value: !lambda "return id(global_cycles_count);"
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "+", text_font: roboto, align: CENTER }
              - button:
                  x: 275
                  y: 244
                  width: 35
                  height: 35
                  on_press:
                    - lambda: |-
                        id(global_cycles_count) -= 0.5;
                        if (id(global_cycles_count) < 0.5) id(global_cycles_count) = 0.5;
                    - lvgl.label.update:
                        id: cycles_number
                        text: !lambda |-
                          static char text[20];
                          snprintf(text, sizeof(text), "%.1f", id(global_cycles_count));
                          return text;
                    - globals.set:
                        id: cycles_count
                        value: !lambda "return id(global_cycles_count);"
                    - number.set:
                        id: cycle_number
                        value: !lambda "return id(global_cycles_count);"
                    - lvgl.label.update:
                        id: pump_runtime_label
                        text: !lambda |-
                          static char buf[16];
                          float volume = id(global_pool_length) * id(global_pool_width) * id(global_pool_depth); // m³
                          float flow = id(pump_flow_rate); // m³ per hour
                          float cycles = id(global_cycles_count);
                          float temp = id(owm_temperature).has_state() ? id(owm_temperature).state : 25.0f;

                          // Prevent divide-by-zero
                          if (flow <= 0.1f) flow = 1.0f;

                          // Temperature correction
                          float temp_factor = 1.0f;
                          if (temp > 40.0f) temp_factor = 1.3f;   // hot water, longer filtering
                          else if (temp < 20.0f) temp_factor = 0.8f; // cold water, shorter filtering

                          float runtime = (volume / (flow*0.001)) * cycles * temp_factor;
                          if (runtime > 24.0f) runtime = 24.0f; // limit to 24 hours

                          sprintf(buf, "%.1f", runtime);
                          id(total_runtime).publish_state(runtime);
                          id(total_runtime_multiple) = runtime;
                          return buf;
                    - script.execute: save_and_refresh_runtime
                  widgets:
                    - label: { text: "-", text_font: roboto, align: CENTER }

              # Pool volume calculation
              - label:
                  {
                    text: "Volume (m^3):",
                    text_font: roboto,
                    x: 10,
                    y: 290,
                    text_color: 0x000000,
                  }
              - label:
                  id: pool_volume_number
                  x: 170
                  y: 290
                  width: 80
                  text_color: 0x000000
                  text: !lambda |-
                    static char buf[16];
                    sprintf(buf, "%.2f", id(pool_volume).state);
                    return buf;
              # Pump runtime calculation
              - label:
                  {
                    text: "Runtime (hrs):",
                    text_font: roboto,
                    x: 10,
                    y: 320,
                    text_color: 0x000000,
                  }
              - label:
                  id: pump_runtime_label
                  x: 170
                  y: 320
                  width: 80
                  text_color: 0x000000
                  text: !lambda |-
                    static char text[20];
                    snprintf(text, sizeof(text), "%.2f", id(total_runtime_multiple));
                    return text;
    #-------------------------------------------
    - id: location_setup_screen
      pad_all: 0
      border_width: 0
      scrollable: false
      widgets:
        - image:
            src: background_image
            x: 0
            y: 0
            width: 480
            height: 480
            align: TOP_LEFT

        - label:
            text: Manual Location Setup
            text_font: roboto24
            align: TOP_MID
            y: 10
            text_color: 0

        # ZIP Code Field
        - label:
            text: "ZIP Code: "
            x: 10
            y: 70
            text_color: 0

        - textarea:
            id: zip_text
            x: 150
            y: 65
            width: 200
            one_line: true
            placeholder_text: !lambda "return id(user_zip_code).c_str();"
            text: !lambda "return id(user_zip_code).c_str();"
            on_value:
              then:
                - lambda: |-
                    id(user_zip_code) = text;
                    ESP_LOGI("location_setup", "ZIP Code set to: %s", id(user_zip_code).c_str());
            on_ready:
              then:
                - lvgl.keyboard.update:
                    id: keyboard_1

                    textarea: zip_text
            on_click:
              then:
                - lvgl.keyboard.update:
                    id: keyboard_1
                    mode: LV_KEYBOARD_MODE_TEXT_LOWER
                    textarea: zip_text
            # on_defocus:
            #   then:
            #     - lvgl.keyboard.update:
            #         id: keyboard_1
            #         mode: number
            #textarea: none

        # Country Field
        - label:
            text: "Country ID: "
            x: 10
            y: 120
            text_color: 0

        - textarea:
            id: country_text
            x: 150
            y: 115
            width: 200
            one_line: true
            #placeholder_text: !lambda 'return id(user_country).c_str();'
            placeholder_text: "e.g., US, CA, GB"
            text: !lambda "return id(user_country).c_str();"
            on_value:
              then:
                - lambda: |-
                    id(user_country) = text;
                    ESP_LOGI("location_setup", "Country set to: %s", id(user_country).c_str());
            on_ready:
              then:
                - lvgl.keyboard.update:
                    id: keyboard_1
                    mode: LV_KEYBOARD_MODE_TEXT_LOWER
                    textarea: country_text

            on_click:
              then:
                - lvgl.keyboard.update:
                    id: keyboard_1
                    mode: LV_KEYBOARD_MODE_TEXT_LOWER
                    textarea: country_text
            # on_defocus:
            #   then:
            #     - lvgl.keyboard.update:
            #         id: keyboard_1
            #textarea: none

        # On-screen Keyboard
        - keyboard:
            id: keyboard_1
            y: 0
            width: 480
            height: 180
            mode: LV_KEYBOARD_MODE_TEXT_LOWER
            on_ready:
              then:
                - logger.log:
                    format: "Keyboard input complete"
                    level: DEBUG
                    tag: location_setup

        # Save Button
        - button:
            x: 150
            y: 190
            width: 200
            height: 45
            bg_color: 38536
            widgets:
              - label:
                  text: "Save Location"
                  x: 15
                  y: -3
            on_click:
              then:
                - lambda: |-
                    // go to main page
                    id(lvgl_comp).show_page(0, LV_SCR_LOAD_ANIM_OVER_RIGHT, 300);
                - logger.log:
                    format: "Manual location saved: ZIP=%s, Country=%s"
                    args: [id(user_zip_code).c_str(), id(user_country).c_str()]
                    level: DEBUG
                    tag: location_setup

    #-------------------------------------------
    - id: splash_screen
      skip: false
      bg_color: 0x000000
      bg_opa: COVER
      border_width: 0
      scrollable: false
      widgets:
        - image:
            id: splash_logo
            src: logo_image
            align: CENTER
            width: 480
            height: 480
            zoom: 1.0
            antialias: true
            # Prevent repeating or tiling
            #tiled: false

#-------------------------------------------
# Internal outputs
#-------------------------------------------
output:
  # Backlight LED
  - platform: ledc
    pin: GPIO38
    id: GPIO38
    frequency: 100Hz

  # Built in 240v relay
  - id: internal_relay_1
    platform: gpio
    pin: 40

  # Additional relays (3 relay model)
  - id: internal_relay_2
    platform: gpio
    pin: 2
  - id: internal_relay_3
    platform: gpio
    pin: 1

#-------------------------------------------
# Internal lights and switches
#-------------------------------------------
light:
  - platform: monochromatic
    output: GPIO38
    name: Backlight
    id: backlight
    restore_mode: ALWAYS_ON

switch:
  - platform: output
    id: pump_relay
    name: "Watering Pump"
    output: internal_relay_3
    on_turn_on:
      then:
        - lvgl.label.update:
            id: current_status_display
            text: "Pump ON - Irrigating..."
        - logger.log: "Watering pump turned ON"
    on_turn_off:
      then:
        - lvgl.label.update:
            id: current_status_display
            text: "Pump OFF - Watering stopped"
        - logger.log: "Watering pump turned OFF"

  - platform: output
    id: sw1
    name: "Light Control"
    output: internal_relay_1
    on_turn_on:
      then:
        - lvgl.widget.update:
            id: sw1_button
            state:
              checked: true
        - lvgl.label.update:
            id: status_label
            text: "Light ON"
            text_color: green_color
    on_turn_off:
      then:
        - lvgl.widget.update:
            id: sw1_button
            state:
              checked: false
        - lvgl.label.update:
            id: status_label
            text: "Light OFF"
            text_color: red_color

  - platform: output
    id: sw2
    name: "Water Pump"
    output: internal_relay_2
    on_turn_on:
      then:
        - lvgl.widget.update:
            id: sw2_button
            state:
              checked: true
        - lvgl.label.update:
            id: status_label
            text: "Water Pump ON"
            text_color: green_color
    on_turn_off:
      then:
        - lvgl.widget.update:
            id: sw2_button
            state:
              checked: false
        - lvgl.label.update:
            id: status_label
            text: "Water Pump OFF"
            text_color: red_color

  - platform: output
    id: sw3
    name: "Watering Valve"
    output: internal_relay_3
    on_turn_on:
      then:
        - lvgl.label.update:
            id: current_status_display
            text: " Pump ON - Irrigating..."
        - logger.log: "Watering pump turned ON"
        - if:
            condition:
              lambda: "return id(valve_training_mode);"
            then:
              - lambda: |-
                  id(valve_training_start_time) = id(time_comp).now().timestamp;
                  ESP_LOGI("irrigation", "Training mode: Valve opened, timer started");
              - lvgl.label.update:
                  id: status_label
                  text: "TRAINING: Valve ON - Timer running"
                  text_color: orange_color
            else:
              - lambda: |-
                  id(sw3_on_time) = id(time_comp).now().timestamp;
                  ESP_LOGI("irrigation", "SW3 started at %u", id(sw3_on_time));
              - lambda: |-
                  float estimated_minutes = 0;
                  if (id(irrigation_needed_liters) > 0 && id(valve_liters_per_minute) > 0) {
                    estimated_minutes = id(irrigation_needed_liters) / id(valve_liters_per_minute);
                  }
                  ESP_LOGI("irrigation", "Water started - estimated %.1f minutes needed", estimated_minutes);
              - lvgl.label.update:
                  id: status_label
                  text: !lambda |-
                    static char msg[80];
                    float est_min = id(irrigation_needed_liters) / id(valve_liters_per_minute);
                    snprintf(msg, sizeof(msg), "Water ON (est. %.1f min)", est_min);
                    return msg;
                  text_color: green_color
        - lvgl.widget.update:
            id: sw3_button
            state:
              checked: true
    on_turn_off:
      then:
        - lvgl.label.update:
            id: current_status_display
            text: "Pump OFF - Watering stopped"
        - logger.log: "Watering pump turned OFF"
        - if:
            condition:
              lambda: "return id(valve_training_mode) && id(valve_training_start_time) > 0;"
            then:
              - lambda: |-
                  int training_duration = id(time_comp).now().timestamp - id(valve_training_start_time);
                  float training_minutes = training_duration / 60.0f;
                  
                  // Calculate flow rate based on known bucket volume
                  if (training_minutes > 0.25f) {  // Minimum 15 seconds for valid training
                    float vol = id(bucket_volume_liters);
                    if (vol <= 0.0f) vol = 10.0f;
                    id(valve_liters_per_minute) = vol / training_minutes;
                    ESP_LOGI("irrigation", "Training complete: %.1f min for %.1f L → %.2f L/min",
                             training_minutes, vol, id(valve_liters_per_minute));
                  } else {
                    ESP_LOGW("irrigation", "Training too short (%.2fs). Keep previous calibration.", training_minutes * 60.0f);
                  }
                  
                  id(valve_training_start_time) = 0;
                  id(valve_training_mode) = false;
              - lvgl.label.update:
                  id: status_label
                  text: !lambda |-
                    static char msg[100];
                    snprintf(msg, sizeof(msg), "Calibration: %.2f L/min (bucket %.1fL)", id(valve_liters_per_minute), id(bucket_volume_liters));
                    return msg;
                  text_color: green_color
              - delay: 3s
              - lvgl.label.update:
                  id: status_label
                  text: "Valve calibration saved"
                  text_color: blue_color
            else:
              - if:
                  condition:
                    lambda: "return !id(valve_training_mode) && id(sw3_on_time) > 0;"
                  then:
                    - lambda: |-
                        int run_secs = id(time_comp).now().timestamp - id(sw3_on_time);
                        id(sw3_on_time) = 0;
                        float minutes = run_secs / 60.0f;
                        float water_delivered = id(valve_liters_per_minute) * minutes;
                        id(irrigation_needed_liters) = std::max(0.0f, id(irrigation_needed_liters) - water_delivered);
                        ESP_LOGI("irrigation", "SW3 stopped: ran %.1f min, delivered %.1fL, remaining: %.1fL",
                                 minutes, water_delivered, id(irrigation_needed_liters));
              - lvgl.label.update:
                  id: status_label
                  text: "Watering stopped"
                  text_color: red_color
        - lvgl.widget.update:
            id: sw3_button
            state:
              checked: false

#-------------------------------------------
# Scripts for automation logic
#-------------------------------------------
script:
  - id: save_and_refresh_runtime
    then:
      - globals.set:
          id: total_runtime_multiple
          value: !lambda "return id(total_runtime_multiple);"
      - lvgl.label.update:
          id: summer_max_display
          text: !lambda |-
            static char text[15];
            snprintf(text, sizeof(text), "%.2f hrs", id(total_runtime_multiple));
            return text;
      - lvgl.label.update:
          id: pump_runtime_label
          text: !lambda |-
            static char buf[16];
            sprintf(buf, "%.2f", id(total_runtime_multiple));
            return buf;
      - logger.log:
          format: "Runtime saved: %.2f hours"
          args: ['id(total_runtime_multiple)']
          
  - id: manual_irrigation_test
    then:
      - logger.log: "Manual irrigation test started"
      - lvgl.label.update:
          id: current_status_display
          text: " Starting test irrigation..."
      - switch.turn_on: pump_relay
      - lambda: |-
          id(irrigation_duration_remaining) = 2; // 2 minute test
      - lvgl.label.update:
          id: current_status_display
          text: "Test irrigation running - 2 min"
      - delay: 60s # 1 minute
      - lambda: |-
          id(irrigation_duration_remaining) = 1;
      - lvgl.label.update:
          id: current_status_display
          text: " Test irrigation running - 1 min"
      - delay: 60s # 1 more minute (total 2 minutes)
      - switch.turn_off: pump_relay
      - lambda: |-
          id(irrigation_duration_remaining) = 0;
      - lvgl.label.update:
          id: current_status_display
          text: "Test irrigation completed"
      - logger.log: "Manual irrigation test completed"

  - id: reset_irrigation_settings
    then:
      - logger.log: "Resetting irrigation settings to defaults"
      - lvgl.label.update:
          id: current_status_display
          text: " Resetting settings..."
      - number.set:
          id: field_area_input
          value: 48
      - number.set:
          id: valve_flow_rate_input
          value: 20
      - number.set:
          id: daily_rainfall_input
          value: 0
      - number.set:
          id: irrigation_schedule_hour_input
          value: 6
      - number.set:
          id: irrigation_schedule_minute_input
          value: 0
      - lambda: |-
          id(auto_irrigation_enabled) = true;
          // Reset all irrigation globals to defaults
          id(field_area_m2) = 48.0;
          id(valve_liters_per_minute) = 20.0;
          id(daily_rainfall_mm) = 0.0;
          id(irrigation_schedule_hour) = 6;
          id(irrigation_schedule_minute) = 0;
      - lvgl.widget.update:
          id: auto_irrigation_toggle
          state:
            checked: true
      - lvgl.label.update:
          id: auto_irrigation_label
          text: "Auto Irrigation: ON"
      - script.execute: calculate_irrigation_needs
      - delay: 1s
      - lvgl.label.update:
          id: current_status_display
          text: "Settings reset to defaults"
      - logger.log: "Watering settings reset to defaults"

  - id: toggle_wifi_popup
    then:
      - lambda: |-
          id(current_page) = 0;  // Set current page to main screen settings
          id(wifi_popup_visible) = !id(wifi_popup_visible);
      - if:
          condition:
            lambda: "return id(wifi_popup_visible);"
          then:
            - lvgl.widget.show: wifi_popup_obj
            # Update all WiFi info when showing popup
            - lvgl.label.update:
                id: wifi_status_text
                text: !lambda |-
                  if (wifi::global_wifi_component->is_connected()) {
                    return "Connected";
                  } else {
                    return "Disconnected";
                  }
            - lvgl.label.update:
                id: wifi_ssid_text
                text: !lambda |-
                  if (id(wifi_ssid).has_state()) {
                    return id(wifi_ssid).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_bssid_text
                text: !lambda |-
                  if (id(wifi_bssid).has_state()) {
                    return id(wifi_bssid).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_rssi_text
                text: !lambda |-
                  if (id(wifi_rssi).has_state()) {
                    static char rssi_text[20];
                    snprintf(rssi_text, sizeof(rssi_text), "%.0f dBm", id(wifi_rssi).state);
                    return rssi_text;
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_ip_text
                text: !lambda |-
                  if (id(ip_address).has_state()) {
                    return id(ip_address).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_gateway_text
                text: !lambda |-
                  if (id(wifi_gateway).has_state()) {
                    return id(wifi_gateway).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_subnet_text
                text: !lambda |-
                  if (id(wifi_subnet).has_state()) {
                    return id(wifi_subnet).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_dns_text
                text: !lambda |-
                  if (id(wifi_dns).has_state()) {
                    return id(wifi_dns).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_mac_text
                text: !lambda |-
                  if (id(wifi_mac).has_state()) {
                    return id(wifi_mac).state.c_str();
                  }
                  return "N/A";
            - delay: 1s
          else:
            - lvgl.widget.hide: wifi_popup_obj
            - delay: 1s

  - id: update_wifi_details
    then:
      - if:
          condition:
            lambda: "return (wifi::global_wifi_component->is_connected());"
          then:
            # Update all WiFi info when showing popup
            - lvgl.label.update:
                id: wifi_status_text
                text: !lambda |-
                  if (wifi::global_wifi_component->is_connected()) {
                    return "Connected";
                  } else {
                    return "Disconnected";
                  }
            - lvgl.label.update:
                id: wifi_ssid_text
                text: !lambda |-
                  if (id(wifi_ssid).has_state()) {
                    return id(wifi_ssid).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_bssid_text
                text: !lambda |-
                  if (id(wifi_bssid).has_state()) {
                    return id(wifi_bssid).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_rssi_text
                text: !lambda |-
                  if (id(wifi_rssi).has_state()) {
                    static char rssi_text[20];
                    snprintf(rssi_text, sizeof(rssi_text), "%.0f dBm", id(wifi_rssi).state);
                    return rssi_text;
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_ip_text
                text: !lambda |-
                  if (id(ip_address).has_state()) {
                    return id(ip_address).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_gateway_text
                text: !lambda |-
                  if (id(wifi_gateway).has_state()) {
                    return id(wifi_gateway).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_subnet_text
                text: !lambda |-
                  if (id(wifi_subnet).has_state()) {
                    return id(wifi_subnet).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_dns_text
                text: !lambda |-
                  if (id(wifi_dns).has_state()) {
                    return id(wifi_dns).state.c_str();
                  }
                  return "N/A";
            - lvgl.label.update:
                id: wifi_mac_text
                text: !lambda |-
                  if (id(wifi_mac).has_state()) {
                    return id(wifi_mac).state.c_str();
                  }
                  return "N/A";
          # else:
          #   - lvgl.widget.hide: wifi_popup_obj

  - id: goto_settings
    then:
      - delay: 1000ms
      - lvgl.widget.update:
          id: settings_page
          hidden: false
      - lvgl.widget.redraw:
  #  irrigation calculation script
  - id: calculate_irrigation_needs
    then:
      - lambda: |-
          // Calculate base daily runtime (inputs are in HOURS; convert to MINUTES for scheduling)
          float winter_hours = id(winter_min_runtime);
          float summer_hours = id(summer_max_runtime);
          int winter_minutes = (int) roundf(winter_hours * 60.0f);
          int summer_minutes = (int) roundf(summer_hours * 60.0f);
          int daily_runtime;

          // Seasonal factor based on day of year
          float seasonal_factor = 1.0;
          if (id(seasonal_pump_enabled)) {
            auto now = id(time_comp).now();
            int day_of_year = now.day_of_year;
            if (day_of_year <= 80 || day_of_year >= 355) {
              seasonal_factor = 0.0; // Winter solstice
            } else if (day_of_year >= 172 && day_of_year <= 264) {
              seasonal_factor = 1.0; // Summer solstice
            } else if (day_of_year < 172) {
              seasonal_factor = (day_of_year - 80) / 92.0; // Spring
            } else {
              seasonal_factor = 1.0 - ((day_of_year - 264) / 91.0); // Fall
            }

            daily_runtime = winter_minutes + (int)((summer_minutes - winter_minutes) * seasonal_factor);
          } else {
            // Use summer max as fixed runtime
            daily_runtime = summer_minutes;
          }

          // Temperature adjustment
          float temp_multiplier = 1.0f;
          float temp_now = NAN;
          if (id(owm_temperature).has_state()) {
            temp_now = id(owm_temperature).state;
            float temp_diff = temp_now - id(reference_temperature);
            temp_multiplier = 1.0f + (temp_diff * id(temp_rate_percent) / 100.0f);
          }

          // Apply temperature adjustment and clamp to min/max (all in minutes)
          daily_runtime = (int) roundf(daily_runtime * temp_multiplier);
          if (daily_runtime < winter_minutes) daily_runtime = winter_minutes;
          if (daily_runtime > summer_minutes) daily_runtime = summer_minutes;
          
          // Safety minimum: ensure at least 30 minutes for window to work
          if (daily_runtime < 30) {
            ESP_LOGW("irrigation", "Daily runtime too small (%d min), using minimum 30 min. Check summer_max_runtime setting!", daily_runtime);
            daily_runtime = 30;
          }

          id(calculated_daily_runtime) = daily_runtime;

          ESP_LOGI("irrigation_calc", "DETAILED: seasonal_enabled=%d day_of_year=%d seasonal_factor=%.3f temp_now=%.1fC temp_mult=%.3f winter=%d summer=%d calculated=%d",
                   id(seasonal_pump_enabled), (id(time_comp).now().day_of_year), seasonal_factor,
                   isnan(temp_now) ? -999.0f : temp_now, temp_multiplier, winter_minutes, summer_minutes, daily_runtime);
          ESP_LOGI("irrigation_calc", "seasonal=%d winter=%.2f h(%d m) summer=%.2f h(%d m) factor=%.2f temp=%.2fC mult=%.3f runtime=%d m",
                   id(seasonal_pump_enabled), winter_hours, winter_minutes, summer_hours, summer_minutes,
                   seasonal_factor, isnan(temp_now) ? -999.0f : temp_now, temp_multiplier, daily_runtime);

          // Calculate block runtimes based on number of blocks
          switch(id(pump_runtime_blocks)) {
            case 1:
              // All time in center block
              id(center_block_runtime) = daily_runtime;
              id(free_block_runtime) = 0;
              break;
            case 2:
              // Half in center, half in free block
              id(center_block_runtime) = daily_runtime / 2;
              id(free_block_runtime) = daily_runtime / 2;
              break;
            case 3:
              // 1/3 in center, 2/3 divided in free blocks
              id(center_block_runtime) = daily_runtime / 3;
              id(free_block_runtime) = daily_runtime / 3;
              break;
            case 4:
              // 1/4 in center, 3/4 divided in free blocks
              id(center_block_runtime) = daily_runtime / 4;
              id(free_block_runtime) = daily_runtime / 4;
              break;
          }

          ESP_LOGI("irrigation", "Daily runtime: %d min, Center block: %d min, Free blocks: %d min each", 
                   daily_runtime, id(center_block_runtime), id(free_block_runtime));

  - id: start_valve_training
    then:
      - if:
          condition:
            lambda: "return !id(valve_training_mode);"
          then:
            - lambda: |-
                id(valve_training_mode) = true;
                ESP_LOGI("irrigation", "Training mode activated - Turn ON valve manually");
            - lvgl.label.update:
                id: status_label
                text: "Training: Turn ON valve manually, then OFF when done"
                text_color: orange_color
          else:
            - lambda: |-
                id(valve_training_mode) = false;
                ESP_LOGI("irrigation", "Training mode cancelled");
            - lvgl.label.update:
                id: status_label
                text: "Training cancelled"
                text_color: red_color

  - id: update_qr_display
    then:
      - component.update: ip_address # Force update the IP sensor first
      - delay: 500ms
      - lvgl.qrcode.update:
          id: settings_qr
          text: !lambda |-
            if (id(ip_address).has_state() && !id(ip_address).state.empty()) {
              return "phijo-smart-device.local/";
            }
            return "http://192.168.4.1/";

      - lvgl.label.update:
          id: qr_url_label
          text: !lambda |-
            if (id(ip_address).has_state() && !id(ip_address).state.empty()) {
              return ("http://" + id(ip_address).state).c_str();
            }
            return "Waiting for IP address...";

  - id: notify_web_portal
    then:
      - component.update: ip_address # Force update IP sensor
      - delay: 500ms
      - if:
          condition:
            wifi.connected:
          then:
            - lvgl.image.update:
                id: wifi_space
                src: wifi_icon_online
            - lvgl.label.update:
                id: status_label
                text: " "
                text_color: ha_blue
            - logger.log:
                format: "Web portal active at http://%s"
                args:
                  [
                    'id(ip_address).has_state() ? id(ip_address).state.c_str() : "unknown"',
                  ]
                #Update QR code when WiFi is connected
            - lvgl.qrcode.update:
                id: settings_qr
                text: http://phijo-smart-device.local
            - lvgl.label.update:
                id: qr_url_label
                text: !lambda |-
                  if (id(ip_address).has_state() && !id(ip_address).state.empty()) {
                    return ("http://" + id(ip_address).state + "/").c_str();
                  }
                  return "Getting IP address...";
          else:
            - lvgl.image.update:
                id: wifi_space
                src: wifi_icon_offline
            - lvgl.label.update:
                id: status_label
                text: "No internet. Connect to AP: PhiJo Smart Products"
                text_color: orange_color
            - logger.log: "No internet. Connect to AP: PhiJo Smart Products"
            # Update QR code for AP mode
            - lvgl.qrcode.update:
                id: settings_qr
                text: "http://192.168.4.1/"
            - lvgl.label.update:
                id: qr_url_label
                text: "http://192.168.4.1/"

      - lvgl.label.update:
          id: ip_address_label
          text: !lambda |-
            if (id(ip_address).has_state() && !id(ip_address).state.empty()) {
              return "WiFi: " + id(ip_address).state;
            } else {
              return "WiFi: Not connected";
            }
  - id: run_scheduled_irrigation
    then:
      - if:
          condition:
            lambda: "return id(auto_irrigation_enabled) && !id(pump_relay).state;"
          then:
            - logger.log: "Starting scheduled irrigation"
            - script.execute: calculate_irrigation_needs
            - lambda: |-
                auto now = id(time_comp).now();
                int current_minutes = now.hour * 60 + now.minute;
                bool should_run = false;
                int runtime_minutes = 0;

                // Check center block (always around 14:00)
                int center_start = (id(center_pump_time_hour) * 60) - (id(center_block_runtime) / 2);
                int center_end = (id(center_pump_time_hour) * 60) + (id(center_block_runtime) / 2);

                if (current_minutes >= center_start && current_minutes <= center_end) {
                  should_run = true;
                  runtime_minutes = id(center_block_runtime) - (current_minutes - center_start);
                  ESP_LOGI("irrigation", "Running center block, %d minutes remaining", runtime_minutes);
                }

                // Check free blocks if more than 1 block configured
                if (!should_run && id(pump_runtime_blocks) >= 2) {
                  int free_start2 = id(free_block2_start_hour) * 60 + id(free_block2_start_minute);
                  int free_end2 = free_start2 + id(free_block_runtime);
                  
                  if (current_minutes >= free_start2 && current_minutes <= free_end2) {
                    should_run = true;
                    runtime_minutes = free_end2 - current_minutes;
                    ESP_LOGI("irrigation", "Running free block 2, %d minutes remaining", runtime_minutes);
                  }
                }

                if (!should_run && id(pump_runtime_blocks) >= 3) {
                  int free_start3 = id(free_block3_start_hour) * 60 + id(free_block3_start_minute);
                  int free_end3 = free_start3 + id(free_block_runtime);
                  
                  if (current_minutes >= free_start3 && current_minutes <= free_end3) {
                    should_run = true;
                    runtime_minutes = free_end3 - current_minutes;
                    ESP_LOGI("irrigation", "Running free block 3, %d minutes remaining", runtime_minutes);
                  }
                }

                if (!should_run && id(pump_runtime_blocks) >= 4) {
                  int free_start4 = id(free_block4_start_hour) * 60 + id(free_block4_start_minute);
                  int free_end4 = free_start4 + id(free_block_runtime);
                  
                  if (current_minutes >= free_start4 && current_minutes <= free_end4) {
                    should_run = true;
                    runtime_minutes = free_end4 - current_minutes;
                    ESP_LOGI("irrigation", "Running free block 4, %d minutes remaining", runtime_minutes);
                  }
                }

                if (!should_run) {
                  ESP_LOGW("irrigation", "Current time not in any irrigation block");
                  return;
                }

                id(irrigation_duration_remaining) = runtime_minutes;

                // Check if it's summer (add water) or winter (remove water)
                bool is_summer = (now.month >= 4 && now.month <= 9);

            - if:
                condition:
                  lambda: |-
                    auto now = id(time_comp).now();
                    return (now.month >= 4 && now.month <= 9); // Summer months
                then:
                  # Summer: Turn on valve to ADD water
                  - switch.turn_on: sw3 # Irrigation Valve
                  - delay: 2s
                  - switch.turn_on: sw2 # Water Pump
                else:
                  # Winter: Turn on pump only to REMOVE water
                  - switch.turn_off: sw3 # Ensure valve is closed
                  - switch.turn_on: sw2 # Water Pump only

            - while:
                condition:
                  lambda: "return id(irrigation_duration_remaining) > 0 && id(sw2).state;"
                then:
                  - delay: 60s
                  - lambda: |-
                      id(irrigation_duration_remaining)--;
                      ESP_LOGD("irrigation", "Irrigation remaining: %d minutes", id(irrigation_duration_remaining));

            # Turn off both pump and valve
            - switch.turn_off: sw2
            - switch.turn_off: sw3

  - id: time_display_update
    then:
      #- script.execute: notify_web_portal
      - logger.log:
          format: "TIME DEBUG: HA connected: %s, Time valid: %s"
          args:
            [
              'id(api_server).is_connected() ? "YES" : "NO"',
              'id(time_comp).now().is_valid() ? "YES" : "NO"',
            ]
      - lvgl.label.update:
          id: digital_clock
          text: !lambda |-
            auto now = id(time_comp).now();
            if (!now.is_valid()) {
              now = id(sntp_time).now();
            }
            static char time_buf[6];
            sprintf(time_buf, "%02d:%02d", now.hour, now.minute);
            return time_buf;
      - lvgl.label.update:
          id: full_date_label
          text: !lambda |-
            auto now = id(time_comp).now();
            if (!now.is_valid()) {
              now = id(sntp_time).now();
            }
            static const char * const day_names[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
            static const char * const mon_names[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
            static char date_buf[32];
            sprintf(date_buf, "%s, %s %d, %d", day_names[now.day_of_week - 1], mon_names[now.month-1], now.day_of_month, now.year);
            return date_buf;
      # Update sunrise/sunset times
      - lvgl.label.update:
          id: sunrise_time_label
          text: !lambda |-
            auto sunrise_opt = id(sun_comp).sunrise(0.0);
            if (sunrise_opt.has_value()) {
              auto sunrise = sunrise_opt.value();
              static char buf[6];
              sprintf(buf, "%02d:%02d", sunrise.hour, sunrise.minute);
              return buf;
            }
            auto now = id(time_comp).now();
            int day_of_year = now.day_of_year;
            float season_factor = sin((day_of_year - 80) * M_PI / 182.5f);
            int sunrise_h = 6 + (int)(season_factor * 1.5f);
            int sunrise_m = 30 + (int)(season_factor * 15.0f);
            static char buf[6];
            sprintf(buf, "%02d:%02d", sunrise_h, sunrise_m);
            return buf;
      - lvgl.label.update:
          id: sunset_time_label
          text: !lambda |-
            auto sunset_opt = id(sun_comp).sunset(0.0);
            if (sunset_opt.has_value()) {
              auto sunset = sunset_opt.value();
              static char buf[6];
              sprintf(buf, "%02d:%02d", sunset.hour, sunset.minute);
              return buf;
            }
            auto now = id(time_comp).now();
            int day_of_year = now.day_of_year;
            float season_factor = sin((day_of_year - 80) * M_PI / 182.5f);
            int sunset_h = 18 + (int)(season_factor * 2.5f);
            int sunset_m = 30 + (int)(season_factor * 15.0f);
            static char buf[6];
            sprintf(buf, "%02d:%02d", sunset_h, sunset_m);
            return buf;
      # Weather display updates (no automation logic)
      - lvgl.label.update:
          id: weather_label
          text: !lambda |-
            if (id(weather_condition).has_state()) {
              return id(weather_condition).state.c_str();
            }
            return "Loading ...";
      #  Update temperature label
      - lvgl.label.update:
          id: temperature_label
          text: !lambda |-
            if (id(owm_temperature).has_state()) {
              static char temp_text[50];
              if (id(owm_feels_like).has_state()) {
                snprintf(temp_text, sizeof(temp_text), "%.1f°C feels %.1f°C", 
                        id(owm_temperature).state, id(owm_feels_like).state);
              } else {
                snprintf(temp_text, sizeof(temp_text), "Temperature: %.1f°C", id(owm_temperature).state);
              }
              return temp_text;
            }
            return "Temperature: --°C";

  # Keep existing time_update but remove automation calls
  - id: time_update
    then:
      - script.execute: time_display_update
      # Remove the automation logic from here

  # Modified check_light_schedules with state change prevention
  - id: check_light_schedules
    then:
      - lambda: |-
          // Log entry to verify script runs
          static int entry_log_counter = 0;
          if (++entry_log_counter >= 1) { // Every 60 * 10s = 10 minutes
            entry_log_counter = 0;
            ESP_LOGI("automation", "check_light_schedules: script executed (10min mark)");
          }

          auto now = id(time_comp).now();
          if (!now.is_valid()) {
            static int invalid_time_count = 0;
            if (++invalid_time_count >= 1) { // Log every 5 minutes if stuck
              invalid_time_count = 0;
              ESP_LOGW("automation", "Time invalid - skipping automation check");
            }
            return;
          }

          // Log automation status every 5 minutes
          static int log_counter = 0;
          if (++log_counter >= 30) { // 30 * 10s = 5 minutes
            log_counter = 0;
            ESP_LOGI("automation", "=== STATUS: SW1:%s SW2:%s SW3:%s | Overrides: SW1:%d SW2:%d SW3:%s ===",
                    id(sw1).state ? "ON" : "OFF",
                    id(sw2).state ? "ON" : "OFF", 
                    id(sw3).state ? "ON" : "OFF",
                    id(sw1_manual_override_time) > 0 ? 1 : 0,
                    id(sw2_manual_override_time) > 0 ? 1 : 0,
                    id(sw3_manual_override_time) > 0 ? "YES" : "NO");
            ESP_LOGI("automation", "Seasonal pump: %s, Daily runtime: %d min, Blocks: %d",
                    id(seasonal_pump_enabled) ? "ENABLED" : "DISABLED",
                    id(calculated_daily_runtime), id(pump_runtime_blocks));
          }

          // Check for manual override timeouts (24 hours = 86400 seconds)
          if (id(sw1_manual_override_time) > 0 && 
              now.timestamp - id(sw1_manual_override_time) > 86400) {
            id(sw1_manual_override_time) = 0;
            ESP_LOGI("automation", "SW1 override expired - automation re-enabled");
          }
          if (id(sw2_manual_override_time) > 0 && 
              now.timestamp - id(sw2_manual_override_time) > 86400) {
            id(sw2_manual_override_time) = 0;
            ESP_LOGI("automation", "SW2 override expired - automation re-enabled");
          }
          if (id(sw3_manual_override_time) > 0 && 
              now.timestamp - id(sw3_manual_override_time) > 86400) {
            id(sw3_manual_override_time) = 0;
            ESP_LOGI("automation", "SW3 override expired - automation re-enabled");
          }

          // Only run automations if not in manual override mode
          // ---- SWITCH 1: SUNRISE/SUNSET CONTROL WITH USER SETTINGS ----
          
          // Log sun times every 10s for debugging and derive epoch timestamps
          auto sunrise_opt = id(sun_comp).sunrise(0.0);
          auto sunset_opt = id(sun_comp).sunset(0.0);
          
          // Seconds since start of today (local time)
          uint32_t seconds_since_midnight = (now.hour * 3600u) + (now.minute * 60u) + now.second;
          uint32_t day_start_ts = now.timestamp - seconds_since_midnight;

          // Hold hour/minute for logs and epoch timestamps for comparisons
          int sunrise_h = 0, sunrise_m = 0, sunset_h = 0, sunset_m = 0;
          uint32_t sunrise_ts = 0, sunset_ts = 0;
          bool using_computed = false;

          if (!sunrise_opt.has_value() || !sunset_opt.has_value()) {
            // Sun component not ready - compute approximate times for Portugal (Algarve)
            int day_of_year = now.day_of_year;
            float season_factor = sin((day_of_year - 80) * M_PI / 182.5f);
            sunrise_h = 6 + (int)(season_factor * 1.5f);
            sunrise_m = 30 + (int)(season_factor * 15.0f);
            sunset_h = 18 + (int)(season_factor * 2.5f);
            sunset_m = 30 + (int)(season_factor * 15.0f);

            sunrise_ts = day_start_ts + (uint32_t)(sunrise_h * 3600 + sunrise_m * 60);
            sunset_ts = day_start_ts + (uint32_t)(sunset_h * 3600 + sunset_m * 60);

            using_computed = true;
            ESP_LOGW("light_time", "SW1: COMPUTED (sun component failed) now=%02d:%02d sunrise=%02d:%02d sunset=%02d:%02d mode=%d state=%d",
                     now.hour, now.minute, sunrise_h, sunrise_m, sunset_h, sunset_m,
                     id(automation_mode), id(sw1).state ? 1 : 0);
          } else {
            auto sunrise_time = sunrise_opt.value();
            auto sunset_time = sunset_opt.value();
            sunrise_h = sunrise_time.hour; sunrise_m = sunrise_time.minute;
            sunset_h = sunset_time.hour; sunset_m = sunset_time.minute;
            sunrise_ts = sunrise_time.timestamp; sunset_ts = sunset_time.timestamp;

            ESP_LOGI("light_time", "SW1: now=%02d:%02d sunrise=%02d:%02d sunset=%02d:%02d mode=%d state=%d off_time=%lld override=%d",
                     now.hour, now.minute, sunrise_h, sunrise_m, sunset_h, sunset_m,
                     id(automation_mode), id(sw1).state ? 1 : 0,
                     (long long)id(sw1_off_time), id(sw1_manual_override_time) > 0 ? 1 : 0);
            
            // Log timer details for debugging
            if (id(sw1).state && id(sw1_off_time) > 0) {
              int32_t time_until_off = (int32_t)(id(sw1_off_time) - now.timestamp);
              ESP_LOGI("light_time", "SW1 timer: now_ts=%u off_ts=%u time_until_off=%ds (%d min)",
                       now.timestamp, id(sw1_off_time), time_until_off, time_until_off / 60);
            }
          }

          // Use unified epoch timestamps for automation below
          
          if (id(sw1_manual_override_time) == 0) {
            // Clear stale off timer if light is OFF and timer already passed
            if (!id(sw1).state && id(sw1_off_time) > 0 && now.timestamp >= id(sw1_off_time)) {
              id(sw1_off_time) = 0;
              ESP_LOGD("automation", "SW1 off_time cleared (stale timer)");
            }
            
            // ===== AUTOMATION MODE LOGIC =====
            // Mode 0: Duration - Light on after sunset for X hours
            // Mode 1: Until Time - Light on from sunset until specific time
            // Mode 2: Between - Light on from sunset to sunrise
            // Mode 3: Manual - Manual button press with duration
            // Mode -1: No mode selected - Light should be OFF
            
            int mode = id(automation_mode);
            
            // If no mode selected, ensure light is OFF
            if (mode == -1) {
              if (id(sw1).state) {
                id(sw1).turn_off();
                id(sw1_off_time) = 0;
                ESP_LOGI("automation", "No automation mode selected: SW1 turned OFF");
              }
              // Skip all other SW1 automation logic
            } else {
            
            // Sunrise automation - turn on before sunrise if configured
            if (mode != 3 && id(sunrise_duration_hours) > 0) {
              int sunrise_seconds = id(sunrise_duration_hours) * 3600;
              
              // Check if it's time to turn on before sunrise
              if ((int32_t)(sunrise_ts - now.timestamp) <= sunrise_seconds && 
                  (int32_t)(sunrise_ts - now.timestamp) > (sunrise_seconds - 60) && 
                  !id(sw1_before_sunrise) && !id(sw1).state) {
                  id(sw1).turn_on();
                  id(sw1_before_sunrise) = true;
                  ESP_LOGI("automation", "SW1 turned ON - %d hours before sunrise (mode=%d)", id(sunrise_duration_hours), mode);
              }
              
              // Check if it's sunrise time - turn off
              if (abs((int32_t)(sunrise_ts - now.timestamp)) < 60 && 
                  id(sw1_before_sunrise) && id(sw1).state) {
                  id(sw1).turn_off();
                  id(sw1_before_sunrise) = false;
                  id(sw1_off_time) = 0;
                  ESP_LOGI("automation", "SW1 turned OFF - sunrise reached");
              }
            }
            
            // Sunset automation logic
            int sunset_window = 900; // 15 minutes to catch late checks
            int32_t time_since_sunset = (int32_t)(now.timestamp - sunset_ts);
            bool in_sunset_window = (time_since_sunset >= -sunset_window && time_since_sunset <= sunset_window);
            bool past_sunset_today = (time_since_sunset > 0 && time_since_sunset < 3600); // Within 1 hour after
            
            // Special handling for Between Times mode (mode 2): Check if we're currently in the sunset-to-sunrise period
            if (mode == 2 && !id(sw1).state && id(sw1_off_time) == 0) {
              // Calculate next sunrise timestamp
              uint32_t next_sunrise_ts;
              auto next_sunrise = id(sun_comp).sunrise(1.0);
              if (next_sunrise.has_value()) {
                next_sunrise_ts = next_sunrise.value().timestamp;
              } else {
                // Fallback: compute tomorrow's sunrise
                int day_of_year = now.day_of_year + 1;
                if (day_of_year > 365) day_of_year = 1;
                float season_factor = sin((day_of_year - 80) * M_PI / 182.5f);
                int next_sunrise_h = 6 + (int)(season_factor * 1.5f);
                int next_sunrise_m = 30 + (int)(season_factor * 15.0f);
                uint32_t next_day_start = day_start_ts + 86400u;
                next_sunrise_ts = next_day_start + (uint32_t)(next_sunrise_h * 3600 + next_sunrise_m * 60);
              }
              
              // Check if we're between today's sunset and tomorrow's sunrise
              if (now.timestamp > sunset_ts && now.timestamp < next_sunrise_ts) {
                id(sw1).turn_on();
                id(sw1_off_time) = next_sunrise_ts;
                int hrs_until = (next_sunrise_ts - now.timestamp) / 3600;
                int mins_until = ((next_sunrise_ts - now.timestamp) % 3600) / 60;
                ESP_LOGI("automation", "SW1 ON - Between mode catchup: already past sunset, on until sunrise in %dh%dm (off_ts=%u)", 
                         hrs_until, mins_until, id(sw1_off_time));
              }
            }
            
            // Special handling for Duration mode (mode 0): Check if we're still within the duration period
            if (mode == 0 && !id(sw1).state && id(sw1_off_time) == 0) {
              uint32_t expected_off_time = sunset_ts + (id(sunset_duration_hours) * 3600);
              // If we're past sunset but before expected off time, turn on
              if (now.timestamp > sunset_ts && now.timestamp < expected_off_time) {
                id(sw1).turn_on();
                id(sw1_off_time) = expected_off_time;
                int mins_left = (expected_off_time - now.timestamp) / 60;
                ESP_LOGI("automation", "SW1 ON - Duration mode catchup: %d mins left of %d hr duration", 
                         mins_left, id(sunset_duration_hours));
              }
            }
            
            // Special handling for Until Time mode (mode 1): Check if we're before the until time
            if (mode == 1 && !id(sw1).state && id(sw1_off_time) == 0) {
              uint32_t until_ts = day_start_ts + 
                                  (uint32_t)id(sunset_until_time_hour) * 3600u + 
                                  (uint32_t)id(sunset_until_time_minute) * 60u;
              // If until_time is before sunset, it's tomorrow
              if (until_ts < sunset_ts) {
                until_ts += 86400u;
              }
              // If we're past sunset but before until time, turn on
              if (now.timestamp > sunset_ts && now.timestamp < until_ts) {
                id(sw1).turn_on();
                id(sw1_off_time) = until_ts;
                int mins_left = (until_ts - now.timestamp) / 60;
                ESP_LOGI("automation", "SW1 ON - Until Time mode catchup: %d mins until %02d:%02d", 
                         mins_left, id(sunset_until_time_hour), id(sunset_until_time_minute));
              }
            }
            
            // Turn on at sunset (except in manual mode 3)
            if (mode != 3 && (in_sunset_window || past_sunset_today) && 
                !id(sw1).state && id(sw1_off_time) == 0) {
                id(sw1).turn_on();
                
                // Calculate off time based on automation mode
                if (mode == 0) {
                  // Duration mode: sunset + X hours
                  id(sw1_off_time) = sunset_ts + (id(sunset_duration_hours) * 3600);
                  ESP_LOGI("automation", "SW1 ON - Duration mode: %d hrs from sunset (off at %u)", 
                           id(sunset_duration_hours), id(sw1_off_time));
                  
                } else if (mode == 1) {
                  // Until Time mode: specific time (could be today or tomorrow)
                  uint32_t until_ts = day_start_ts + 
                                      (uint32_t)id(sunset_until_time_hour) * 3600u + 
                                      (uint32_t)id(sunset_until_time_minute) * 60u;
                  
                  // If until_time is before sunset (e.g., 02:00), it's tomorrow
                  if (until_ts < sunset_ts) {
                    until_ts += 86400u;
                  }
                  id(sw1_off_time) = until_ts;
                  ESP_LOGI("automation", "SW1 ON - Until Time mode: off at %02d:%02d (ts=%u)", 
                           id(sunset_until_time_hour), id(sunset_until_time_minute), id(sw1_off_time));
                  
                } else if (mode == 2) {
                  // Between Times mode: sunset to next sunrise
                  auto next_sunrise = id(sun_comp).sunrise(1.0);
                  if (next_sunrise.has_value()) {
                    id(sw1_off_time) = next_sunrise.value().timestamp;
                  } else {
                    // Fallback: compute tomorrow's sunrise
                    int day_of_year = now.day_of_year + 1;
                    if (day_of_year > 365) day_of_year = 1;
                    float season_factor = sin((day_of_year - 80) * M_PI / 182.5f);
                    int next_sunrise_h = 6 + (int)(season_factor * 1.5f);
                    int next_sunrise_m = 30 + (int)(season_factor * 15.0f);
                    uint32_t next_day_start = day_start_ts + 86400u;
                    id(sw1_off_time) = next_day_start + (uint32_t)(next_sunrise_h * 3600 + next_sunrise_m * 60);
                  }
                  int hrs_until = (id(sw1_off_time) - now.timestamp) / 3600;
                  int mins_until = ((id(sw1_off_time) - now.timestamp) % 3600) / 60;
                  ESP_LOGI("automation", "SW1 ON - Between mode: sunset to sunrise in %dh%dm (off_ts=%u)", 
                           hrs_until, mins_until, id(sw1_off_time));
                }
                
                ESP_LOGI("automation", "SW1 turned ON at sunset (mode=%d, time_since_sunset=%ds)", mode, time_since_sunset);
            }
            
            // Check timer to turn off (except in Between mode - that uses sunrise)
            if (id(sw1).state && !id(sw1_before_sunrise) && 
                id(sw1_off_time) > 0 && now.timestamp >= id(sw1_off_time)) {
              id(sw1).turn_off();
              id(sw1_off_time) = 0;
              ESP_LOGI("automation", "SW1 turned OFF - timer expired (mode=%d)", mode);
            }
            
            } // End of else block for mode != -1
          }
          
          // Check manual mode timer even when in override (manual button press)
          if (id(sw1_manual_override_time) > 0 && id(sw1).state && 
              id(sw1_off_time) > 0 && now.timestamp >= id(sw1_off_time)) {
            id(sw1).turn_off();
            id(sw1_off_time) = 0;
            ESP_LOGI("automation", "SW1 manual OFF - timer expired after %d hours", id(manual_duration_hours));
          }
          
          // Keep lambda open for subsequent SW2/SW3 logic

          // ---- SWITCH 2: SEASONAL POOL PUMP CONTROL ----
          // Debug: Check conditions every 60 seconds
          static int pump_debug_counter = 0;
          if (++pump_debug_counter >= 6) { // Log every 60 seconds (6 * 10s = 60s)
            pump_debug_counter = 0;
            ESP_LOGI("pump_debug", "SW2 Check: override=%d, seasonal=%d, daily_runtime=%d, blocks=%d, center_hour=%d",
                    id(sw2_manual_override_time), id(seasonal_pump_enabled), 
                    id(calculated_daily_runtime), id(pump_runtime_blocks), id(center_pump_time_hour));
          }
          
          // Log why pump automation might be disabled
          ESP_LOGI("pump_debug", "SW2 automation check: manual_override=%d seasonal_enabled=%d (both must be 0 and 1 to run)",
                   id(sw2_manual_override_time), id(seasonal_pump_enabled));

          if (id(sw2_manual_override_time) == 0 && id(seasonal_pump_enabled)) {
            // Calculate if pump should be running based on runtime blocks
            // PRIMARY SOURCE: total_runtime_multiple from pool pump settings (in hours)
            // FALLBACK: calculated_daily_runtime (in minutes) from seasonal calculation
            bool in_runtime_window = false;
            int blocks = id(pump_runtime_blocks);
            
            // Convert total_runtime_multiple (hours) to minutes and use as primary runtime
            int daily_runtime = (int) roundf(id(total_runtime_multiple) * 60.0f);
            
            // Fallback to calculated_daily_runtime if total_runtime_multiple is not set yet
            if (daily_runtime <= 0) {
              daily_runtime = id(calculated_daily_runtime);
              ESP_LOGI("pump_time", "Using fallback calculated_daily_runtime=%d min (total_runtime_multiple=%.2fh is zero)",
                       daily_runtime, id(total_runtime_multiple));
            } else {
              // Sync back to calculated_daily_runtime for consistency
              id(calculated_daily_runtime) = daily_runtime;
            }
            
            if (daily_runtime > 0) {
              int block_duration = daily_runtime / blocks; // minutes per block
              int center_hour = id(center_pump_time_hour);
              int half_block = block_duration / 2;
              ESP_LOGI("pump_time", "now=%02d:%02d:%02d ts=%u", now.hour, now.minute, now.second, now.timestamp);
              ESP_LOGI("pump_time", "state=%s center=%02d:00", id(sw2).state ? "ON" : "OFF", center_hour);
              
              // Check center block
              int center_start_min = (center_hour * 60) - half_block;
              int center_end_min = (center_hour * 60) + half_block;
              int current_min = (now.hour * 60) + now.minute;
              
                    ESP_LOGI("pump_time", "runtime=%d min blocks=%d block_dur=%d half=%d | SOURCE: total_runtime_multiple=%.2fh = %d min",
                             daily_runtime, blocks, block_duration, half_block, id(total_runtime_multiple), daily_runtime);
              ESP_LOGD("pump_time", "Center block: start=%02d:%02d, end=%02d:%02d, now=%02d:%02d",
                      center_start_min/60, center_start_min%60, center_end_min/60, center_end_min%60,
                      now.hour, now.minute);
              
              if (current_min >= center_start_min && current_min < center_end_min) {
                in_runtime_window = true;
                ESP_LOGI("pump_time", "✓ IN CENTER BLOCK NOW");
              }
              
              // Check additional free blocks
              if (!in_runtime_window && blocks >= 2) {
                int block2_start = (id(free_block2_start_hour) * 60) + id(free_block2_start_minute);
                int block2_end = block2_start + block_duration;
                if (current_min >= block2_start && current_min < block2_end) {
                  in_runtime_window = true;
                  ESP_LOGD("pump", "In BLOCK 2: %02d:%02d", now.hour, now.minute);
                }
              }
              
              if (!in_runtime_window && blocks >= 3) {
                int block3_start = (id(free_block3_start_hour) * 60) + id(free_block3_start_minute);
                int block3_end = block3_start + block_duration;
                if (current_min >= block3_start && current_min < block3_end) {
                  in_runtime_window = true;
                  ESP_LOGD("pump", "In BLOCK 3: %02d:%02d", now.hour, now.minute);
                }
              }
              
              if (!in_runtime_window && blocks >= 4) {
                int block4_start = (id(free_block4_start_hour) * 60) + id(free_block4_start_minute);
                int block4_end = block4_start + block_duration;
                if (current_min >= block4_start && current_min < block4_end) {
                  in_runtime_window = true;
                  ESP_LOGD("pump", "In BLOCK 4: %02d:%02d", now.hour, now.minute);
                }
              }
            }
            
            // Turn pump ON if in window and not already on
            if (in_runtime_window && !id(sw2).state) {
              id(sw2).turn_on();
              ESP_LOGI("automation", "✓✓✓ SW2 PUMP turned ON - runtime block active (daily: %d min)", daily_runtime);
            }
            // Turn pump OFF if outside window and currently on
            else if (!in_runtime_window && id(sw2).state) {
              id(sw2).turn_off();
              id(sw2_off_time) = 0;  // clear any pending timers when schedule says OFF
              ESP_LOGI("automation", "SW2 PUMP turned OFF - outside runtime window");
            }
            else if (in_runtime_window && id(sw2).state) {
              // Already on - no action needed
            }
            else if (!in_runtime_window && !id(sw2).state) {
              // Already off - no action needed
            }          
          }

          // Similar logic for SW2 
          // ---- SWITCH 3: IRRIGATION VALVE CONTROL ----
          if (id(sw3_manual_override_time) == 0) {
            // Check if irrigation is needed and it's appropriate time
            bool should_irrigate = false;
            // Recompute today's net water need based on mode
            float evap_liters = id(calculated_evaporation_liters);
            float rainfall_liters = id(daily_rainfall_mm) * id(field_area_m2) / 1000.0f; // consistent with UI
            float need_liters = 0.0f;
            if (id(sw3_winter_mode)) {
              // WINTER: drain excess (rain - evaporation)
              need_liters = std::max(0.0f, rainfall_liters - evap_liters);
            } else {
              // SUMMER: fill deficit (evaporation - rain)
              need_liters = std::max(0.0f, evap_liters - rainfall_liters);
            }
            id(irrigation_needed_liters) = need_liters;
            ESP_LOGI("automation", "SW3 need: mode=%s evap=%.1fL rain=%.1fL need=%.1fL",
                     id(sw3_winter_mode) ? "WINTER(DRAIN)" : "SUMMER(FILL)",
                     evap_liters, rainfall_liters, need_liters);
            
            // Only irrigate during appropriate hours (early morning or evening)
            int hour = now.hour;
            bool appropriate_time = (hour >= 5 && hour <= 7) || (hour >= 18 && hour <= 20);
            
            if (appropriate_time && id(irrigation_needed_liters) > 10.0) {
              if (id(sw3_winter_mode)) {
                // Winter mode: Only irrigate if really needed (>15L)
                should_irrigate = id(irrigation_needed_liters) > 15.0;
              } else {
                // Summer mode: Irrigate if needed (>10L)
                should_irrigate = id(irrigation_needed_liters) > 10.0;
              }
            }
            
            // Turn on irrigation if needed
            if (should_irrigate && !id(sw3).state) {
              // Calculate irrigation time based on needs
              float irrigation_minutes = id(irrigation_needed_liters) / id(valve_liters_per_minute);
              irrigation_minutes = std::min(irrigation_minutes, 30.0f); // Max 30 minutes
              
              // Turn on valve first
              id(sw3).turn_on();
              delay(2000); // Wait 2 seconds
              
              // SUMMER(fill): optionally assist with pump; WINTER(drain): do not turn pump on
              if (!id(sw3_winter_mode)) {
                if (!id(sw2).state) {
                  id(sw2).turn_on();
                  ESP_LOGI("automation", "SW2 PUMP turned ON - for filling");
                }
              }
              
              id(sw3_off_time) = now.timestamp + (int)(irrigation_minutes * 60);
              ESP_LOGI("automation", "SW3 VALVE turned ON - %.1f min for %.1fL (mode: %s)", 
                      irrigation_minutes, id(irrigation_needed_liters),
                      id(sw3_winter_mode) ? "WINTER" : "SUMMER");
            }
            // Turn off irrigation when timer expires
            if (id(sw3).state && now.timestamp >= id(sw3_off_time) && id(sw3_off_time) > 0) {
              // Turn off pump first (if it was turned on for irrigation)
              bool pump_was_for_irrigation = id(sw2).state && !id(seasonal_pump_enabled);
              if (pump_was_for_irrigation) {
                id(sw2).turn_off();
                ESP_LOGI("automation", "SW2 PUMP turned OFF - irrigation complete");
              }
              
              id(sw3).turn_off();
              id(sw3_off_time) = 0;
                    ESP_LOGI("automation", "SW3 VALVE OFF - Remaining need: %.1fL", id(irrigation_needed_liters));
            }
          }

#-------------------------------------------
# Graphics and Fonts
#-------------------------------------------
font:
  - file: "gfonts://Roboto"
    id: roboto24
    size: 24
    bpp: 4

  - file: "gfonts://Roboto"
    id: roboto
    size: 18
    bpp: 4

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icons24
    size: 24
    bpp: 4
    glyphs: [
        "\U000F0335", # mdi-lightbulb
        "\U000F0769", # mdi-ceiling-light
        "\U000F06B5", # mdi-lamp
        "\U000F08DD", # mdi-floor-lamp
        "\U000F12BA", # mdi-string-lights
        "\U000F0493", # mdi-settings
        "\U000F02DC", # mdi-home
        "\U000F0599", # mdi-weather-sunny
        "\U000F0F64", # mdi-weather-night
        "\U000F0596", # mdi-weather-pouring
        "\U000F050F", # mdi-thermometer
      ]

  - file: "fonts/materialdesignicons-webfont.ttf"
    id: light40
    size: 40
    bpp: 4
    glyphs: [
        "\U000F0335", # mdi-lightbulb
        "\U000F0769", # mdi-ceiling-light
        "\U000F06B5", # mdi-lamp
        "\U000F08DD", # mdi-floor-lamp
        "\U000F12BA", # mdi-string-lights
      ]

  - file: "gfonts://Roboto"
    id: roboto_large
    size: 72
    bpp: 4

#-------------------------------------------
# Touchscreen gt911 i2c
#-------------------------------------------
i2c:
  - id: bus_a
    sda: GPIO19
    scl: GPIO45

touchscreen:
  platform: gt911
  transform:
    mirror_x: false
    mirror_y: false
  id: my_touchscreen
  display: my_display

  on_touch:
    - lambda: |-
        ESP_LOGD("touch", "Touch at (%d, %d)", touch.x, touch.y);
        id(last_touch_time) = millis();
        // Check if touch is in top-left WiFi area (reduced to actual icon size: 50x50 at position 10,10)
        if (touch.x >= 5 && touch.x <= 65 && touch.y >= 5 && touch.y <= 65 && (id(lvgl_comp).get_current_page()) == 0) {
          ESP_LOGD("touch", "WiFi area touched at (%d, %d)", touch.x, touch.y);
          // execute the page toggle script 
          id(toggle_wifi_popup).execute();
          return; // Exit early if WiFi area touched
        }
        if (touch.x >= 390 && touch.y >= 60 && touch.y <= 110 && (id(lvgl_comp).get_current_page()) == 1) {
          ESP_LOGD("touch", "light area touched at (%d, %d)", touch.x, touch.y);
          // go to the light settings Page
          id(current_page) = 4;
          id(lvgl_comp).show_page(4, LV_SCR_LOAD_ANIM_OVER_LEFT, 300);
          return; // Exit early if pump settings  area touched
        }
        if (touch.x >= 390 && touch.y >= 150 && touch.y <= 200 && (id(lvgl_comp).get_current_page()) == 1) {
          ESP_LOGD("touch", "pump area touched at (%d, %d)", touch.x, touch.y);
          // go to the pump settings Page
          id(current_page) = 2;
          id(lvgl_comp).show_page(2, LV_SCR_LOAD_ANIM_OVER_LEFT, 300);
          return; // Exit early if pump settings  area touched
        }
        if (touch.x >= 390 && touch.y >= 240 && touch.y <= 290 && (id(lvgl_comp).get_current_page()) == 1) {
          ESP_LOGD("touch", "valve area touched at (%d, %d)", touch.x, touch.y);
          // go to the pump settings Page
          id(current_page) = 5;
          id(lvgl_comp).show_page(5, LV_SCR_LOAD_ANIM_OVER_LEFT, 300);
          return; // Exit early if pump settings  area touched
          }
        if (!id(touch_active)) {
          // Store initial touch position
          id(touch_start_y) = touch.y;
          id(touch_active) = true;
        }
        // Always update end position while touching
        id(touch_end_y) = touch.y;

  on_release:
    - lambda: |-
        // Calculate swipe distance
        int swipe_distance = id(touch_start_y) - id(touch_end_y);
        int min_swipe_distance = 80;

        ESP_LOGD("swipe", "Start: %d, End: %d, Distance: %d", id(touch_start_y), id(touch_end_y), swipe_distance);

        // Reset touch tracking
        id(touch_active) = false;

        if (abs(swipe_distance) > min_swipe_distance) {
          if (swipe_distance > 0) {
            ESP_LOGD("swipe", "Swipe up detected - next page");
          } else {
            ESP_LOGD("swipe", "Swipe down detected - previous page");
          }
        }
    - if:
        condition:
          lambda: "return (id(touch_start_y) - id(touch_end_y)) > 20;"
        then:
          - lvgl.page.next:
    - if:
        condition:
          lambda: "return (id(touch_end_y) - id(touch_start_y)) > 80;"
        then:
          - lvgl.page.previous:
    - if:
        condition: lvgl.is_paused
        then:
          - light.turn_on: backlight
          - lvgl.resume:
          - lvgl.widget.redraw:

#-------------------------------------------
# Display st7701s spi
#-------------------------------------------
spi:
  - id: lcd_spi
    clk_pin: GPIO48
    mosi_pin: GPIO47

display:
  - platform: st7701s
    id: my_display
    update_interval: never
    auto_clear_enabled: False
    spi_mode: MODE3
    color_order: RGB
    invert_colors: False
    dimensions:
      width: 480
      height: 480
    cs_pin: 39
    de_pin: 18
    hsync_pin: 16
    vsync_pin: 17
    pclk_pin: 21
    pclk_frequency: 12MHz
    pclk_inverted: False
    hsync_pulse_width: 8
    hsync_front_porch: 10
    hsync_back_porch: 20
    vsync_pulse_width: 8
    vsync_front_porch: 10
    vsync_back_porch: 10
    init_sequence:
      - 1
      # Custom sequences are an array, first byte is command, the rest are data.
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x10] # CMD2_BKSEL_BK0
      - [0xCD, 0x00] # disable MDT flag
    data_pins:
      red:
        - 11 #r1
        - 12 #r2
        - 13 #r3
        - 14 #r4
        - 0 #r5
      green:
        - 8 #g0
        - 20 #g1
        - 3 #g2
        - 46 #g3
        - 9 #g4
        - 10 #g5
      blue:
        - 4 #b1
        - 5 #b2
        - 6 #b3
        - 7 #b4
        - 15 #b5
    on_page_change:
      #- lvgl.widget.refresh: summer_max_display
      - lvgl.label.update:
          id: summer_max_display
          text: !lambda |-
            static char buf[16];
            sprintf(buf, "%.2f", id(total_runtime_multiple));
            return buf;
      #- from: pool_pump_settings_page
      # - to: pump_settings_page
      #   then:
      #     - lvgl.widget.refresh: summer_max_display
      #     - lambda: |-
      #         ESP_LOGD("display", "Page changed from ppol to 2");
image:
  - file: "images/background.jpg"
    id: background_image
    resize: 480x480
    type: RGB565

  - file: "images/logo.png"
    id: logo_image
    resize: 480x480
    type: RGB565

  - file: "images/wifi.png"
    id: wifi_icon
    resize: 50x50
    type: RGB565

  - file: "images/wifi_icons.jpg"
    id: wifi_icon_online
    resize: 50x50
    type: RGB565

  - file: "images/wt.png"
    id: wifi_icon_onlines
    resize: 50x50
    type: RGB565

  - file: "images/offline.jpg"
    id: wifi_icon_offline
    resize: 50x50
    type: RGB565

  - file: "images/cloud.png"
    id: cloud_icon
    resize: 24x24

    type: RGB565
  - file: "images/settings.jpg"
    id: settings_icon
    resize: 60x60

    type: RGB565
  - file: "images/pressure.png"
    id: pressure
    resize: 24x24
    type: RGB565

  - file: "images/temp.png"
    id: thermometer_icon
    resize: 24x24
    type: RGB565

  - file: "images/humidity.png"
    id: humidity_icon
    resize: 24x24
    type: RGB565

  - file: "images/wind.png"
    id: wind_icon
    resize: 24x24
    type: RGB565

  - file: "images/visibility.png"
    id: visibility_icon
    resize: 24x24
    type: RGB565

interval:
  - interval: 10s
    then:
      - script.execute: update_wifi_details

  - interval: 5s
    then:
      - lambda: |-
          // Check if 60 seconds have passed since last touch
          if (millis() - id(last_touch_time) > 60000) {
            // Go to page 1 if not already there
            if (id(lvgl_comp).get_current_page() != 0) {
            id(current_page) = 1; // Update current page
            ESP_LOGD("lvgl", "Switching to page 0 due to inactivity");
              id(lvgl_comp).show_page(0, LV_SCR_LOAD_ANIM_FADE_ON, 300);
            }
            // Reset the timer to prevent constant page switching
            //id(last_touch_time) = millis();
          }
          ESP_LOGI("POOL Length", ": %.2f meters", id(pool_length).state);
          ESP_LOGI("runtime multiple", ": %.2f minutes", id(total_runtime_multiple));
          ESP_LOGI("runtime", ": %.2f minutes", id(total_runtime).state);
          ESP_LOGI("POOL Width", ": %.2f meters", id(pool_width).state);
          ESP_LOGI("POOL Depth", ": %.2f meters", id(pool_depth).state);
          ESP_LOGI("POOL Volume", ": %.2f liters", id(pool_volume).state);
          ESP_LOGI("PUMP Flow Rate", ": %.2f L/min", id(valve_flow_rate_input).state);
          ESP_LOGI("CALCULATED cycle", ": %.2f minutes", id(cycle_number).state);
          ESP_LOGI("cycle", ": %.2f minutes", id(global_cycles_count));
          ESP_LOGI("BLOCKS ", ": %d", id(pump_runtime_blocks));
          ESP_LOGI("CENTER BLOCK ", ": %.2f ", id(block_number).state);
          ESP_LOGI("PUMP RUNTIME BLOCKS ", ": %.2f minutes", id(center_block_runtime));
      # - lvgl.label.update:
      #     id: cycles_number
      #     text: !lambda |-
      #       static char buf[20];
      #       sprintf(buf, "%.2", id(global_cycles_count));
      #       return buf;
  - interval: 60s # Every 5 minutes
    then:
      - script.execute: calculate_irrigation_needs
      - lambda: |-
          // Update all display elements on the water pump settings page
          if (id(current_page) == 1) {  // If on water pump settings page
            id(lvgl_comp).loop();
          }
  - interval: 20s
    then:
      - lambda: |-
          auto now = id(time_comp).now();
          if (!now.is_valid() || now.year < 2020) {
            ESP_LOGW("time", "Time appears invalid, requesting resync");

          }
      - script.execute: time_display_update
      #- script.execute: update_qr_display

  - interval: 10s
    then:
      - script.execute: notify_web_portal
      - script.execute: check_light_schedules
      #- lvgl.widget.refresh: summer_max_display

      # - lvgl.label.update:
      #     id: summer_max_display
      #     text: !lambda |-
      #       static char buf[16];
      #       sprintf(buf, "%.1f", id(total_runtime).state);
      #       return buf;
      # - lvgl.label.update:
      #     id: pump_runtime_label
      #     text: !lambda |-
      #       static char buf[20];
      #       snprintf(buf, sizeof(buf), "%.2f", id(total_runtime_multiple));
      #       ESP_LOGD("UPDATING RUNTIME ", "Test remaining runtime: %.2f minutes", id(total_runtime_multiple));
      #       ESP_LOGD("UPDATING RUNTIME state", "Test remaining runtime: %.2f minutes", id(total_runtime).state);
      #       return buf;

  - interval: 30s
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - logger.log: "fechting  request..."
            # - http_request.get:
            #     url: "https://api.ip2location.io/"  #  Replace 'demo' with your API key
            #     capture_response: true
            #     on_response:
            #       then:
            #         - lambda: |-
            #             const char *data = body.c_str();

            #             const char *lat_ptr = strstr(data, "\"latitude\":");
            #             const char *lon_ptr = strstr(data, "\"longitude\":");
            #             const char *city_ptr = strstr(data, "\"city_name\":\"");

            #             if (lat_ptr && lon_ptr) {
            #               float lat = atof(lat_ptr + 11);
            #               float lon = atof(lon_ptr + 12);
            #               id(current_lat) = lat;
            #               id(current_lon) = lon;
            #               ESP_LOGI("geo", "Detected lat=%.4f, lon=%.4f", lat, lon);
            #             }

            #             if (city_ptr) {
            #               city_ptr += 13;
            #               const char *end = strchr(city_ptr, '"');
            #               if (end) {
            #                 std::string city(city_ptr, end - city_ptr);
            #                 id(location_name_str) = city;
            #                 ESP_LOGI("geo", "Detected city: %s", city.c_str());
            #               }
            #             }

      # - lvgl.label.update:
      #     id: location_display_label
      #     text: !lambda |-
      #       return id(location_name_str).c_str();

  - interval: 60s
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - logger.log: "Making weather API request..."
            # - http_request.get:
            #     url: "https://api.ip2location.io/"
            #     capture_response: true
            #     on_response:
            #       then:
            #         - lambda: |-
            #             ESP_LOGI("geo", "Geo API response: %s", body.c_str());

            #             // Minimal JSON extraction using find/substr to reduce stack load
            #             size_t lat_pos = body.find("\"latitude\":");
            #             size_t lon_pos = body.find("\"longitude\":");
            #             size_t city_pos = body.find("\"city_name\":");

            #             if (lat_pos != std::string::npos && lon_pos != std::string::npos) {
            #               float lat = atof(body.substr(lat_pos + 11).c_str());
            #               float lon = atof(body.substr(lon_pos + 12).c_str());
            #               id(current_lat) = lat;
            #               id(current_lon) = lon;
            #               ESP_LOGI("geo", "Lat: %.4f, Lon: %.4f", lat, lon);
            #             }

            #             if (city_pos != std::string::npos) {
            #               size_t start = city_pos + 13;
            #               size_t end = body.find("\"", start);
            #               if (end != std::string::npos) {
            #                // id(location_name_str) = body.substr(start, end - start);
            #                 ESP_LOGI("geo", "City: %s", id(location_name_str).c_str());
            #               }
            #             }
            - delay: 3s
            - lvgl.label.update:
                id: location_display_label
                text: !lambda |-
                  return id(location_name_str).c_str();

            # Step 1: Get coordinates from ZIP code
            - logger.log: "Fetching coordinates from ZIP code..."
            - http_request.get:
                url: !lambda |-
                  char url[512];
                  sprintf(url,
                    "http://api.openweathermap.org/geo/1.0/zip?zip=%s,%s&appid=b0fed035f1b875bafaf66f85d33f4e71",
                    id(user_zip_code).c_str(), id(user_country).c_str());
                  return std::string(url);
                request_headers:
                  User-Agent: "ESPHome/1.0"
                capture_response: true
                on_response:
                  then:
                    - lambda: |-
                        ESP_LOGD("geo", "Geocoding response: %s", body.c_str());

                        // Parse latitude
                        size_t lat_pos = body.find("\"lat\":");
                        if (lat_pos != std::string::npos) {
                          size_t start = lat_pos + 6;
                          size_t end = body.find(",", start);
                          if (end == std::string::npos) end = body.find("}", start);
                          
                          if (end != std::string::npos) {
                            std::string lat_str = body.substr(start, end - start);
                            id(current_lat) = std::stof(lat_str);
                            ESP_LOGI("geo", "Latitude: %.4f", id(current_lat));
                          }
                        }

                        // Parse longitude
                        size_t lon_pos = body.find("\"lon\":");
                        if (lon_pos != std::string::npos) {
                          size_t start = lon_pos + 6;
                          size_t end = body.find(",", start);
                          if (end == std::string::npos) end = body.find("}", start);
                          
                          if (end != std::string::npos) {
                            std::string lon_str = body.substr(start, end - start);
                            id(current_lon) = std::stof(lon_str);
                            ESP_LOGI("geo", "Longitude: %.4f", id(current_lon));
                          }
                        }

                        // Parse location name
                        size_t name_pos = body.find("\"name\":\"");
                        if (name_pos != std::string::npos) {
                          size_t start = name_pos + 8;
                          size_t end = body.find("\"", start);
                          
                          if (end != std::string::npos) {
                            id(location_name_str) = body.substr(start, end - start);
                            ESP_LOGI("geo", "Location: %s", id(location_name_str).c_str());
                          }
                        }
                on_error:
                  then:
                    - logger.log: "Failed to fetch coordinates from ZIP code"

            # Step 2: Get weather data using coordinates
            - delay: 2s
            - logger.log: "Making OpenWeatherMap weather API request..."
            - http_request.get:
                url: !lambda |-
                  char url[512];
                  sprintf(url,
                    "http://api.openweathermap.org/data/2.5/weather?lat=%.4f&lon=%.4f&appid=b0fed035f1b875bafaf66f85d33f4e71&units=metric",
                    id(current_lat), id(current_lon));
                  return std::string(url);

                request_headers:
                  User-Agent: "ESPHome/1.0"
                capture_response: true
                on_response:
                  then:
                    - lambda: |-
                        ESP_LOGD("weather", "HTTP Status: %d", response);
                        ESP_LOGD("weather", "Response body: %s", body.c_str());

                        if (body.length() > 0) {
                          
                          // Parse temperature
                          size_t temp_pos = body.find("\"temp\":");
                          if (temp_pos != std::string::npos) {
                            size_t start = temp_pos + 7;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string temp_str = body.substr(start, end - start);
                              float temperature = std::stof(temp_str);
                              id(owm_temperature).publish_state(temperature);
                              ESP_LOGD("weather", "Temperature: %.1f°C", temperature);
                            }
                          }
                          
                          // Parse feels like temperature
                          size_t feels_pos = body.find("\"feels_like\":");
                          if (feels_pos != std::string::npos) {
                            size_t start = feels_pos + 13;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string feels_str = body.substr(start, end - start);
                              float feels_like = std::stof(feels_str);
                              id(owm_feels_like).publish_state(feels_like);
                            }
                          }
                          
                          // Parse humidity
                          size_t humidity_pos = body.find("\"humidity\":");
                          if (humidity_pos != std::string::npos) {
                            size_t start = humidity_pos + 11;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string humidity_str = body.substr(start, end - start);
                              float humidity = std::stof(humidity_str);
                              id(owm_humidity).publish_state(humidity);
                              
                            }
                          }
                          
                          // Parse pressure
                          size_t pressure_pos = body.find("\"pressure\":");
                          if (pressure_pos != std::string::npos) {
                            size_t start = pressure_pos + 11;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string pressure_str = body.substr(start, end - start);
                              float pressure = std::stof(pressure_str);
                              id(owm_pressure).publish_state(pressure);
                            }
                          }
                          
                          // Parse wind speed
                          size_t wind_pos = body.find("\"speed\":");
                          if (wind_pos != std::string::npos) {
                            size_t start = wind_pos + 8;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string wind_str = body.substr(start, end - start);
                              float wind_speed = std::stof(wind_str);
                              id(owm_wind_speed).publish_state(wind_speed);
                             
                            }
                          }
                          
                          
                          size_t gust_pos = body.find("\"gust\":");
                          if (gust_pos != std::string::npos) {
                            size_t start = gust_pos + 7;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string gust_str = body.substr(start, end - start);
                              float wind_gust = std::stof(gust_str);
                              id(owm_wind_gust).publish_state(wind_gust);
                              
                            }
                          }
                          
                          // ADD NEW PARSING - Wind direction
                          size_t deg_pos = body.find("\"deg\":");
                          if (deg_pos != std::string::npos) {
                            size_t start = deg_pos + 6;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string deg_str = body.substr(start, end - start);
                              float wind_direction = std::stof(deg_str);
                              id(owm_wind_direction).publish_state(wind_direction);
                              
                              }
                          }
                          
                          // ADD NEW PARSING - Visibility
                          size_t vis_pos = body.find("\"visibility\":");
                          if (vis_pos != std::string::npos) {
                            size_t start = vis_pos + 13;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string vis_str = body.substr(start, end - start);
                              float visibility = std::stof(vis_str) / 1000.0; // Convert meters to kilometers
                              id(owm_visibility).publish_state(visibility);
                              
                            }
                          }
                          
                          // ADD NEW PARSING - Cloud coverage
                          size_t clouds_pos = body.find("\"all\":");
                          if (clouds_pos != std::string::npos) {
                            size_t start = clouds_pos + 6;
                            size_t end = body.find(",", start);
                            if (end == std::string::npos) end = body.find("}", start);
                            
                            if (end != std::string::npos) {
                              std::string clouds_str = body.substr(start, end - start);
                              float cloud_coverage = std::stof(clouds_str);
                              id(owm_clouds).publish_state(cloud_coverage);
                            
                            }
                          }
                          
                          // Parse weather main condition (e.g., "Clear", "Clouds", "Rain")
                          size_t main_pos = body.find("\"main\":\"");
                          if (main_pos != std::string::npos) {
                            size_t start = main_pos + 8;
                            size_t end = body.find("\"", start);
                            
                            if (end != std::string::npos) {
                              std::string main_weather = body.substr(start, end - start);
                              id(weather_condition).publish_state(main_weather);
                             
                            }
                          }
                          
                          // Parse weather description (e.g., "clear sky", "few clouds")
                          size_t desc_pos = body.find("\"description\":\"");
                          if (desc_pos != std::string::npos) {
                            size_t start = desc_pos + 15;
                            size_t end = body.find("\"", start);
                            
                            if (end != std::string::npos) {
                              std::string description = body.substr(start, end - start);
                              // Capitalize first letter
                              if (!description.empty()) {
                                description[0] = std::toupper(description[0]);
                              }
                              id(weather_description).publish_state(description);

                            }
                          }
                          // Parse city name (e.g., "London")
                          size_t name_pos = body.find("\"name\":\"");
                          if (name_pos != std::string::npos) {
                            size_t start = name_pos + 8;  // skip `"name":"`
                            size_t end = body.find("\"", start);
                            if (end != std::string::npos) {
                              std::string city_name = body.substr(start, end - start);
                              id(location_name_str) = city_name;
                              ESP_LOGD("weather", "City name: %s", city_name.c_str());
                              //id(weather_city).publish_state(city_name);
                            }
                          }

                          ESP_LOGD("weather", "Weather data parsing complete - updating display");
                        } else {
                          ESP_LOGW("weather", "Empty response from weather API");
                        }

                    # UPDATE ALL WEATHER LABELS DIRECTLY HERE
                    - lvgl.label.update:
                        id: weather_label
                        text: !lambda |-
                          if (id(weather_condition).has_state()) {
                            return id(weather_condition).state.c_str();
                          }
                          return "Loading...";

                    - lvgl.label.update:
                        id: temperature_label
                        text: !lambda |-
                          if (id(owm_temperature).has_state()) {
                            static char temp_text[60];
                            if (id(owm_feels_like).has_state()) {
                              snprintf(temp_text, sizeof(temp_text), "%.1f°C feels %.1f°C", 
                                      id(owm_temperature).state, id(owm_feels_like).state);
                            } else {
                              snprintf(temp_text, sizeof(temp_text), "Temperature: %.1f°C", id(owm_temperature).state);
                            }
                            return temp_text;
                          }
                          return " --°C";

                    - lvgl.label.update:
                        id: humidity_label
                        text: !lambda |-
                          static char info_text[50];
                          if (id(owm_humidity).has_state()) {
                            snprintf(info_text, sizeof(info_text), " %.0f%% ", 
                                    id(owm_humidity).state);
                          } else {
                            snprintf(info_text, sizeof(info_text), " --%");
                          }
                          return info_text;

                    - lvgl.label.update:
                        id: pressure_label
                        text: !lambda |-
                          static char info_text[50];
                          if ( id(owm_pressure).has_state()) {
                            snprintf(info_text, sizeof(info_text), " %.0fhPa ", 
                                     id(owm_pressure).state);
                          }else {
                            snprintf(info_text, sizeof(info_text), "--%");
                          }
                          return info_text;

                    - lvgl.label.update:
                        id: wind_info_label
                        text: !lambda |-
                          static char wind_text[50];
                          if (id(owm_wind_speed).has_state()) {
                            if (id(owm_wind_gust).has_state() && id(owm_wind_gust).state > id(owm_wind_speed).state) {
                              snprintf(wind_text, sizeof(wind_text), " %.1fm/s", 
                                      id(owm_wind_speed).state);
                            } else {
                              snprintf(wind_text, sizeof(wind_text), "%.1fm/s", id(owm_wind_speed).state);
                            }
                          } else {
                            snprintf(wind_text, sizeof(wind_text), "Wind: --m/s");
                          }
                          return wind_text;

                    - lvgl.label.update:
                        id: visibility_label
                        text: !lambda |-
                          static char vis_text[60];
                          if (id(owm_visibility).has_state() && id(owm_clouds).has_state()) {
                            snprintf(vis_text, sizeof(vis_text), " %.1fkm ", 
                                    id(owm_visibility).state, id(owm_clouds).state);
                          } else if (id(owm_visibility).has_state()) {
                            snprintf(vis_text, sizeof(vis_text), " %.1fkm", id(owm_visibility).state);
                          } else {
                            snprintf(vis_text, sizeof(vis_text), "Visibility: --km");
                          }
                          return vis_text;

                    - logger.log: "All weather display labels updated"

                on_error:
                  then:
                    - logger.log: "Weather API request failed"
          else:
            - logger.log: "WiFi not connected, skipping weather update"

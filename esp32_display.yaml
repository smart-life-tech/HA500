esphome:
  name: esp32display
  friendly_name: ESP32 Display

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "9HLR1P/vVsbBBautrFIB6B2M/YzNR2av+Qn5NnkTI4g="

ota:
    - platform: esphome
      password: "YOUR_OTA_PASSWORD"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp32 Display Fallback"
    password: "YOUR_FALLBACK_PASSWORD"

captive_portal:

# Display configuration for 4848S040 480x480 IPS touchscreen
spi:
  clk_pin: GPIO7
  mosi_pin: GPIO6
  miso_pin: GPIO2

output:
  - platform: ledc
    pin: GPIO8
    id: backlight_output
    frequency: 1000 Hz

light:
  - platform: monochromatic
    output: backlight_output
    name: "Display Backlight"
    id: display_backlight
    restore_mode: ALWAYS_ON

# Time component for clock display
time:
  - platform: homeassistant
    id: esptime
    timezone: America/New_York  # Change to your timezone

display:
  - platform: ili9xxx
    model: ST7789V
    id: my_display
    dimensions:
      width: 480
      height: 480
    reset_pin: GPIO4
    cs_pin: GPIO5
    dc_pin: GPIO9
    rotation: 0
    invert_colors: true
    update_interval: 5s
    lambda: |-
      // Set background color
      it.fill(Color::BLACK);
      
      // Define custom colors
      auto color_navy = Color(0, 0, 128);
      auto color_gray = Color(128, 128, 128);
      auto color_darkblue = Color(0, 0, 139);
      auto color_darkgreen = Color(0, 100, 0);
      auto color_darkorange = Color(255, 140, 0);
      
      // Draw header
      it.rectangle(0, 0, 480, 60, color_navy);
      it.printf(240, 30, id(roboto_medium_20), Color::WHITE, TextAlign::CENTER, "Home Status");
      
      // Draw time and date
      it.printf(240, 80, id(roboto_medium_36), Color::WHITE, TextAlign::CENTER, "%s", id(esptime).now().strftime("%H:%M").c_str());
      it.printf(240, 120, id(roboto_regular_20), color_gray, TextAlign::CENTER, "%s", id(esptime).now().strftime("%A, %b %d").c_str());
      
      // Draw temperature and humidity
      it.rectangle(40, 160, 200, 120, color_darkblue);
      it.printf(140, 190, id(roboto_medium_24), Color::WHITE, TextAlign::CENTER, "Temperature");
      if (id(temperature_sensor).has_state()) {
        it.printf(140, 230, id(roboto_medium_36), Color::WHITE, TextAlign::CENTER, "%.1f°C", id(temperature_sensor).state);
      } else {
        it.printf(140, 230, id(roboto_medium_36), Color::WHITE, TextAlign::CENTER, "--.-°C");
      }
      
      it.rectangle(240, 160, 200, 120, color_darkgreen);
      it.printf(340, 190, id(roboto_medium_24), Color::WHITE, TextAlign::CENTER, "Humidity");
      if (id(humidity_sensor).has_state()) {
        it.printf(340, 230, id(roboto_medium_36), Color::WHITE, TextAlign::CENTER, "%.1f%%", id(humidity_sensor).state);
      } else {
        it.printf(340, 230, id(roboto_medium_36), Color::WHITE, TextAlign::CENTER, "--.-%%");
      }
      
      // Draw light status
      it.rectangle(40, 300, 400, 80, color_darkorange);
      it.printf(240, 330, id(roboto_medium_24), Color::WHITE, TextAlign::CENTER, "Living Room Light: %s", id(light_state).state ? "ON" : "OFF");
      
      // Draw WiFi signal strength
      int rssi = WiFi.RSSI();
      int quality = 0;
      if (rssi <= -100) {
        quality = 0;
      } else if (rssi >= -50) {
        quality = 100;
      } else {
        quality = 2 * (rssi + 100);
      }
      it.printf(440, 30, id(roboto_regular_16), Color::WHITE, TextAlign::RIGHT, "WiFi: %d%%", quality);
      
      // Draw battery status if available
      if (id(battery_level).has_state()) {
        it.printf(440, 50, id(roboto_regular_16), Color::WHITE, TextAlign::RIGHT, "Batt: %.0f%%", id(battery_level).state);
      }



# Touch screen configuration
touchscreen:
  - platform: xpt2046
    id: my_touchscreen
    cs_pin: GPIO10
    interrupt_pin: GPIO13  # Changed from GPIO3 to a non-strapping pin
    display: my_display
    update_interval: 50ms
    threshold: 400
    calibration:
      x_min: 280
      x_max: 3860
      y_min: 340
      y_max: 3860
    transform:
      mirror_x: true
    on_touch:
      - lambda: |-
          ESP_LOGI("touch", "Touch at (%d, %d)", touch.x, touch.y);
          
          // Check if touch is in light control area
          if (touch.x >= 40 && touch.x <= 440 && touch.y >= 300 && touch.y <= 380) {
            id(light_state).toggle();
          }

# For the font issue, you can use the Roboto fonts from Google Fonts
# You need to download these fonts first or use the gfonts component
font:
  - file: "fonts/Roboto-Regular.ttf"
    id: roboto_regular_16
    size: 16
  - file: "fonts/Roboto-Regular.ttf"
    id: roboto_regular_20
    size: 20
  - file: "fonts/Roboto-Medium.ttf"
    id: roboto_medium_20
    size: 20
  - file: "fonts/Roboto-Medium.ttf"
    id: roboto_medium_24
    size: 24
  - file: "fonts/Roboto-Medium.ttf"
    id: roboto_medium_36
    size: 36  

    #timezone: America/New_York  # Change to your timezone
# Example sensors - replace with your actual sensors
sensor:
  - platform: dht
    pin: GPIO11
    model: DHT22
    temperature:
      name: "ESP32 Temperature"
      id: temperature_sensor
    humidity:
      name: "ESP32 Humidity"
      id: humidity_sensor
    update_interval: 60s
  
  - platform: wifi_signal
    name: "ESP32 WiFi Signal"
    update_interval: 60s
  
  - platform: adc
    pin: GPIO1
    name: "Battery Level"
    id: battery_level
    update_interval: 60s
    attenuation: 11db
    filters:
      - lambda: return x / 4095.0 * 100.0;  # Convert to percentage

# Example switch for light control
switch:
  - platform: gpio
    name: "Living Room Light"
    id: light_state
    pin: GPIO12
